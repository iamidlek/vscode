{"version":3,"sources":["../../../../file:/Users/iamidlek/Desktop/mantech/vscode/out-editor-src/vs/base/common/worker/simpleWorker.ts","../../../../vs/base/common/worker/simpleWorker.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nimport { CharCode } from '../charCode.js';\r\nimport { onUnexpectedError, transformErrorForSerialization } from '../errors.js';\r\nimport { Emitter, Event } from '../event.js';\r\nimport { Disposable, IDisposable } from '../lifecycle.js';\r\nimport { AppResourcePath, FileAccess } from '../network.js';\r\nimport { isWeb } from '../platform.js';\r\nimport * as strings from '../strings.js';\r\nimport { URI } from '../uri.js';\r\n\r\nconst DEFAULT_CHANNEL = 'default';\r\nconst INITIALIZE = '$initialize';\r\n\r\nexport interface IWorker extends IDisposable {\r\n\tgetId(): number;\r\n\tpostMessage(message: Message, transfer: ArrayBuffer[]): void;\r\n}\r\n\r\nexport interface IWorkerCallback {\r\n\t(message: Message): void;\r\n}\r\n\r\nexport interface IWorkerFactory {\r\n\tcreate(modules: IWorkerDescriptor, callback: IWorkerCallback, onErrorCallback: (err: any) => void): IWorker;\r\n}\r\n\r\nexport interface IWorkerDescriptor {\r\n\treadonly moduleId: string;\r\n\treadonly esmModuleLocation: URI | undefined;\r\n\treadonly label: string | undefined;\r\n}\r\n\r\nlet webWorkerWarningLogged = false;\r\nexport function logOnceWebWorkerWarning(err: any): void {\r\n\tif (!isWeb) {\r\n\t\t// running tests\r\n\t\treturn;\r\n\t}\r\n\tif (!webWorkerWarningLogged) {\r\n\t\twebWorkerWarningLogged = true;\r\n\t\tconsole.warn('Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq');\r\n\t}\r\n\tconsole.warn(err.message);\r\n}\r\n\r\nconst enum MessageType {\r\n\tRequest,\r\n\tReply,\r\n\tSubscribeEvent,\r\n\tEvent,\r\n\tUnsubscribeEvent\r\n}\r\nclass RequestMessage {\r\n\tpublic readonly type = MessageType.Request;\r\n\tconstructor(\r\n\t\tpublic readonly vsWorker: number,\r\n\t\tpublic readonly req: string,\r\n\t\tpublic readonly channel: string,\r\n\t\tpublic readonly method: string,\r\n\t\tpublic readonly args: any[]\r\n\t) { }\r\n}\r\nclass ReplyMessage {\r\n\tpublic readonly type = MessageType.Reply;\r\n\tconstructor(\r\n\t\tpublic readonly vsWorker: number,\r\n\t\tpublic readonly seq: string,\r\n\t\tpublic readonly res: any,\r\n\t\tpublic readonly err: any\r\n\t) { }\r\n}\r\nclass SubscribeEventMessage {\r\n\tpublic readonly type = MessageType.SubscribeEvent;\r\n\tconstructor(\r\n\t\tpublic readonly vsWorker: number,\r\n\t\tpublic readonly req: string,\r\n\t\tpublic readonly channel: string,\r\n\t\tpublic readonly eventName: string,\r\n\t\tpublic readonly arg: any\r\n\t) { }\r\n}\r\nclass EventMessage {\r\n\tpublic readonly type = MessageType.Event;\r\n\tconstructor(\r\n\t\tpublic readonly vsWorker: number,\r\n\t\tpublic readonly req: string,\r\n\t\tpublic readonly event: any\r\n\t) { }\r\n}\r\nclass UnsubscribeEventMessage {\r\n\tpublic readonly type = MessageType.UnsubscribeEvent;\r\n\tconstructor(\r\n\t\tpublic readonly vsWorker: number,\r\n\t\tpublic readonly req: string\r\n\t) { }\r\n}\r\ntype Message = RequestMessage | ReplyMessage | SubscribeEventMessage | EventMessage | UnsubscribeEventMessage;\r\n\r\ninterface IMessageReply {\r\n\tresolve: (value?: any) => void;\r\n\treject: (error?: any) => void;\r\n}\r\n\r\ninterface IMessageHandler {\r\n\tsendMessage(msg: any, transfer?: ArrayBuffer[]): void;\r\n\thandleMessage(channel: string, method: string, args: any[]): Promise<any>;\r\n\thandleEvent(channel: string, eventName: string, arg: any): Event<any>;\r\n}\r\n\r\nclass SimpleWorkerProtocol {\r\n\r\n\tprivate _workerId: number;\r\n\tprivate _lastSentReq: number;\r\n\tprivate _pendingReplies: { [req: string]: IMessageReply };\r\n\tprivate _pendingEmitters: Map<string, Emitter<any>>;\r\n\tprivate _pendingEvents: Map<string, IDisposable>;\r\n\tprivate _handler: IMessageHandler;\r\n\r\n\tconstructor(handler: IMessageHandler) {\r\n\t\tthis._workerId = -1;\r\n\t\tthis._handler = handler;\r\n\t\tthis._lastSentReq = 0;\r\n\t\tthis._pendingReplies = Object.create(null);\r\n\t\tthis._pendingEmitters = new Map<string, Emitter<any>>();\r\n\t\tthis._pendingEvents = new Map<string, IDisposable>();\r\n\t}\r\n\r\n\tpublic setWorkerId(workerId: number): void {\r\n\t\tthis._workerId = workerId;\r\n\t}\r\n\r\n\tpublic sendMessage(channel: string, method: string, args: any[]): Promise<any> {\r\n\t\tconst req = String(++this._lastSentReq);\r\n\t\treturn new Promise<any>((resolve, reject) => {\r\n\t\t\tthis._pendingReplies[req] = {\r\n\t\t\t\tresolve: resolve,\r\n\t\t\t\treject: reject\r\n\t\t\t};\r\n\t\t\tthis._send(new RequestMessage(this._workerId, req, channel, method, args));\r\n\t\t});\r\n\t}\r\n\r\n\tpublic listen(channel: string, eventName: string, arg: any): Event<any> {\r\n\t\tlet req: string | null = null;\r\n\t\tconst emitter = new Emitter<any>({\r\n\t\t\tonWillAddFirstListener: () => {\r\n\t\t\t\treq = String(++this._lastSentReq);\r\n\t\t\t\tthis._pendingEmitters.set(req, emitter);\r\n\t\t\t\tthis._send(new SubscribeEventMessage(this._workerId, req, channel, eventName, arg));\r\n\t\t\t},\r\n\t\t\tonDidRemoveLastListener: () => {\r\n\t\t\t\tthis._pendingEmitters.delete(req!);\r\n\t\t\t\tthis._send(new UnsubscribeEventMessage(this._workerId, req!));\r\n\t\t\t\treq = null;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn emitter.event;\r\n\t}\r\n\r\n\tpublic handleMessage(message: Message): void {\r\n\t\tif (!message || !message.vsWorker) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (this._workerId !== -1 && message.vsWorker !== this._workerId) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis._handleMessage(message);\r\n\t}\r\n\r\n\tpublic createProxyToRemoteChannel<T extends object>(channel: string, sendMessageBarrier?: () => Promise<void>): T {\r\n\t\tconst handler = {\r\n\t\t\tget: (target: any, name: PropertyKey) => {\r\n\t\t\t\tif (typeof name === 'string' && !target[name]) {\r\n\t\t\t\t\tif (propertyIsDynamicEvent(name)) { // onDynamic...\r\n\t\t\t\t\t\ttarget[name] = (arg: any): Event<any> => {\r\n\t\t\t\t\t\t\treturn this.listen(channel, name, arg);\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t} else if (propertyIsEvent(name)) { // on...\r\n\t\t\t\t\t\ttarget[name] = this.listen(channel, name, undefined);\r\n\t\t\t\t\t} else if (name.charCodeAt(0) === CharCode.DollarSign) { // $...\r\n\t\t\t\t\t\ttarget[name] = async (...myArgs: any[]) => {\r\n\t\t\t\t\t\t\tawait sendMessageBarrier?.();\r\n\t\t\t\t\t\t\treturn this.sendMessage(channel, name, myArgs);\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn target[name];\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn new Proxy(Object.create(null), handler);\r\n\t}\r\n\r\n\tprivate _handleMessage(msg: Message): void {\r\n\t\tswitch (msg.type) {\r\n\t\t\tcase MessageType.Reply:\r\n\t\t\t\treturn this._handleReplyMessage(msg);\r\n\t\t\tcase MessageType.Request:\r\n\t\t\t\treturn this._handleRequestMessage(msg);\r\n\t\t\tcase MessageType.SubscribeEvent:\r\n\t\t\t\treturn this._handleSubscribeEventMessage(msg);\r\n\t\t\tcase MessageType.Event:\r\n\t\t\t\treturn this._handleEventMessage(msg);\r\n\t\t\tcase MessageType.UnsubscribeEvent:\r\n\t\t\t\treturn this._handleUnsubscribeEventMessage(msg);\r\n\t\t}\r\n\t}\r\n\r\n\tprivate _handleReplyMessage(replyMessage: ReplyMessage): void {\r\n\t\tif (!this._pendingReplies[replyMessage.seq]) {\r\n\t\t\tconsole.warn('Got reply to unknown seq');\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst reply = this._pendingReplies[replyMessage.seq];\r\n\t\tdelete this._pendingReplies[replyMessage.seq];\r\n\r\n\t\tif (replyMessage.err) {\r\n\t\t\tlet err = replyMessage.err;\r\n\t\t\tif (replyMessage.err.$isError) {\r\n\t\t\t\terr = new Error();\r\n\t\t\t\terr.name = replyMessage.err.name;\r\n\t\t\t\terr.message = replyMessage.err.message;\r\n\t\t\t\terr.stack = replyMessage.err.stack;\r\n\t\t\t}\r\n\t\t\treply.reject(err);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\treply.resolve(replyMessage.res);\r\n\t}\r\n\r\n\tprivate _handleRequestMessage(requestMessage: RequestMessage): void {\r\n\t\tconst req = requestMessage.req;\r\n\t\tconst result = this._handler.handleMessage(requestMessage.channel, requestMessage.method, requestMessage.args);\r\n\t\tresult.then((r) => {\r\n\t\t\tthis._send(new ReplyMessage(this._workerId, req, r, undefined));\r\n\t\t}, (e) => {\r\n\t\t\tif (e.detail instanceof Error) {\r\n\t\t\t\t// Loading errors have a detail property that points to the actual error\r\n\t\t\t\te.detail = transformErrorForSerialization(e.detail);\r\n\t\t\t}\r\n\t\t\tthis._send(new ReplyMessage(this._workerId, req, undefined, transformErrorForSerialization(e)));\r\n\t\t});\r\n\t}\r\n\r\n\tprivate _handleSubscribeEventMessage(msg: SubscribeEventMessage): void {\r\n\t\tconst req = msg.req;\r\n\t\tconst disposable = this._handler.handleEvent(msg.channel, msg.eventName, msg.arg)((event) => {\r\n\t\t\tthis._send(new EventMessage(this._workerId, req, event));\r\n\t\t});\r\n\t\tthis._pendingEvents.set(req, disposable);\r\n\t}\r\n\r\n\tprivate _handleEventMessage(msg: EventMessage): void {\r\n\t\tif (!this._pendingEmitters.has(msg.req)) {\r\n\t\t\tconsole.warn('Got event for unknown req');\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis._pendingEmitters.get(msg.req)!.fire(msg.event);\r\n\t}\r\n\r\n\tprivate _handleUnsubscribeEventMessage(msg: UnsubscribeEventMessage): void {\r\n\t\tif (!this._pendingEvents.has(msg.req)) {\r\n\t\t\tconsole.warn('Got unsubscribe for unknown req');\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis._pendingEvents.get(msg.req)!.dispose();\r\n\t\tthis._pendingEvents.delete(msg.req);\r\n\t}\r\n\r\n\tprivate _send(msg: Message): void {\r\n\t\tconst transfer: ArrayBuffer[] = [];\r\n\t\tif (msg.type === MessageType.Request) {\r\n\t\t\tfor (let i = 0; i < msg.args.length; i++) {\r\n\t\t\t\tif (msg.args[i] instanceof ArrayBuffer) {\r\n\t\t\t\t\ttransfer.push(msg.args[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (msg.type === MessageType.Reply) {\r\n\t\t\tif (msg.res instanceof ArrayBuffer) {\r\n\t\t\t\ttransfer.push(msg.res);\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis._handler.sendMessage(msg, transfer);\r\n\t}\r\n}\r\n\r\ntype ProxiedMethodName = (`$${string}` | `on${string}`);\r\n\r\nexport type Proxied<T> = { [K in keyof T]: T[K] extends (...args: infer A) => infer R\r\n\t? (\r\n\t\tK extends ProxiedMethodName\r\n\t\t? (...args: A) => Promise<Awaited<R>>\r\n\t\t: never\r\n\t)\r\n\t: never\r\n};\r\n\r\nexport interface IWorkerClient<W> {\r\n\tproxy: Proxied<W>;\r\n\tdispose(): void;\r\n\tsetChannel<T extends object>(channel: string, handler: T): void;\r\n}\r\n\r\nexport interface IWorkerServer {\r\n\tgetChannel<T extends object>(channel: string): Proxied<T>;\r\n}\r\n\r\n/**\r\n * Main thread side\r\n */\r\nexport class SimpleWorkerClient<W extends object> extends Disposable implements IWorkerClient<W> {\r\n\r\n\tprivate readonly _worker: IWorker;\r\n\tprivate readonly _onModuleLoaded: Promise<void>;\r\n\tprivate readonly _protocol: SimpleWorkerProtocol;\r\n\tpublic readonly proxy: Proxied<W>;\r\n\tprivate readonly _localChannels: Map<string, object> = new Map();\r\n\r\n\tconstructor(\r\n\t\tworkerFactory: IWorkerFactory,\r\n\t\tworkerDescriptor: IWorkerDescriptor,\r\n\t) {\r\n\t\tsuper();\r\n\r\n\t\tthis._worker = this._register(workerFactory.create(\r\n\t\t\t{\r\n\t\t\t\tmoduleId: 'vs/base/common/worker/simpleWorker',\r\n\t\t\t\tesmModuleLocation: workerDescriptor.esmModuleLocation,\r\n\t\t\t\tlabel: workerDescriptor.label\r\n\t\t\t},\r\n\t\t\t(msg: Message) => {\r\n\t\t\t\tthis._protocol.handleMessage(msg);\r\n\t\t\t},\r\n\t\t\t(err: any) => {\r\n\t\t\t\t// in Firefox, web workers fail lazily :(\r\n\t\t\t\t// we will reject the proxy\r\n\t\t\t\tonUnexpectedError(err);\r\n\t\t\t}\r\n\t\t));\r\n\r\n\t\tthis._protocol = new SimpleWorkerProtocol({\r\n\t\t\tsendMessage: (msg: any, transfer: ArrayBuffer[]): void => {\r\n\t\t\t\tthis._worker.postMessage(msg, transfer);\r\n\t\t\t},\r\n\t\t\thandleMessage: (channel: string, method: string, args: any[]): Promise<any> => {\r\n\t\t\t\treturn this._handleMessage(channel, method, args);\r\n\t\t\t},\r\n\t\t\thandleEvent: (channel: string, eventName: string, arg: any): Event<any> => {\r\n\t\t\t\treturn this._handleEvent(channel, eventName, arg);\r\n\t\t\t}\r\n\t\t});\r\n\t\tthis._protocol.setWorkerId(this._worker.getId());\r\n\r\n\t\t// Gather loader configuration\r\n\t\tlet loaderConfiguration: any = null;\r\n\r\n\t\tconst globalRequire: { getConfig?(): object } | undefined = (globalThis as any).require;\r\n\t\tif (typeof globalRequire !== 'undefined' && typeof globalRequire.getConfig === 'function') {\r\n\t\t\t// Get the configuration from the Monaco AMD Loader\r\n\t\t\tloaderConfiguration = globalRequire.getConfig();\r\n\t\t} else if (typeof (globalThis as any).requirejs !== 'undefined') {\r\n\t\t\t// Get the configuration from requirejs\r\n\t\t\tloaderConfiguration = (globalThis as any).requirejs.s.contexts._.config;\r\n\t\t}\r\n\r\n\t\t// Send initialize message\r\n\t\tthis._onModuleLoaded = this._protocol.sendMessage(DEFAULT_CHANNEL, INITIALIZE, [\r\n\t\t\tthis._worker.getId(),\r\n\t\t\tJSON.parse(JSON.stringify(loaderConfiguration)),\r\n\t\t\tworkerDescriptor.moduleId,\r\n\t\t]);\r\n\r\n\t\tthis.proxy = this._protocol.createProxyToRemoteChannel(DEFAULT_CHANNEL, async () => { await this._onModuleLoaded; });\r\n\t\tthis._onModuleLoaded.catch((e) => {\r\n\t\t\tthis._onError('Worker failed to load ' + workerDescriptor.moduleId, e);\r\n\t\t});\r\n\t}\r\n\r\n\tprivate _handleMessage(channelName: string, method: string, args: any[]): Promise<any> {\r\n\t\tconst channel: object | undefined = this._localChannels.get(channelName);\r\n\t\tif (!channel) {\r\n\t\t\treturn Promise.reject(new Error(`Missing channel ${channelName} on main thread`));\r\n\t\t}\r\n\t\tif (typeof (channel as any)[method] !== 'function') {\r\n\t\t\treturn Promise.reject(new Error(`Missing method ${method} on main thread channel ${channelName}`));\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\treturn Promise.resolve((channel as any)[method].apply(channel, args));\r\n\t\t} catch (e) {\r\n\t\t\treturn Promise.reject(e);\r\n\t\t}\r\n\t}\r\n\r\n\tprivate _handleEvent(channelName: string, eventName: string, arg: any): Event<any> {\r\n\t\tconst channel: object | undefined = this._localChannels.get(channelName);\r\n\t\tif (!channel) {\r\n\t\t\tthrow new Error(`Missing channel ${channelName} on main thread`);\r\n\t\t}\r\n\t\tif (propertyIsDynamicEvent(eventName)) {\r\n\t\t\tconst event = (channel as any)[eventName].call(channel, arg);\r\n\t\t\tif (typeof event !== 'function') {\r\n\t\t\t\tthrow new Error(`Missing dynamic event ${eventName} on main thread channel ${channelName}.`);\r\n\t\t\t}\r\n\t\t\treturn event;\r\n\t\t}\r\n\t\tif (propertyIsEvent(eventName)) {\r\n\t\t\tconst event = (channel as any)[eventName];\r\n\t\t\tif (typeof event !== 'function') {\r\n\t\t\t\tthrow new Error(`Missing event ${eventName} on main thread channel ${channelName}.`);\r\n\t\t\t}\r\n\t\t\treturn event;\r\n\t\t}\r\n\t\tthrow new Error(`Malformed event name ${eventName}`);\r\n\t}\r\n\r\n\tpublic setChannel<T extends object>(channel: string, handler: T): void {\r\n\t\tthis._localChannels.set(channel, handler);\r\n\t}\r\n\r\n\tprivate _onError(message: string, error?: any): void {\r\n\t\tconsole.error(message);\r\n\t\tconsole.info(error);\r\n\t}\r\n}\r\n\r\nfunction propertyIsEvent(name: string): boolean {\r\n\t// Assume a property is an event if it has a form of \"onSomething\"\r\n\treturn name[0] === 'o' && name[1] === 'n' && strings.isUpperAsciiLetter(name.charCodeAt(2));\r\n}\r\n\r\nfunction propertyIsDynamicEvent(name: string): boolean {\r\n\t// Assume a property is a dynamic event (a method that returns an event) if it has a form of \"onDynamicSomething\"\r\n\treturn /^onDynamic/.test(name) && strings.isUpperAsciiLetter(name.charCodeAt(9));\r\n}\r\n\r\nexport interface IRequestHandler {\r\n\t_requestHandlerBrand: any;\r\n\t[prop: string]: any;\r\n}\r\n\r\nexport interface IRequestHandlerFactory {\r\n\t(workerServer: IWorkerServer): IRequestHandler;\r\n}\r\n\r\n/**\r\n * Worker side\r\n */\r\nexport class SimpleWorkerServer implements IWorkerServer {\r\n\r\n\tprivate _requestHandlerFactory: IRequestHandlerFactory | null;\r\n\tprivate _requestHandler: IRequestHandler | null;\r\n\tprivate _protocol: SimpleWorkerProtocol;\r\n\tprivate readonly _localChannels: Map<string, object> = new Map();\r\n\tprivate readonly _remoteChannels: Map<string, object> = new Map();\r\n\r\n\tconstructor(postMessage: (msg: Message, transfer?: ArrayBuffer[]) => void, requestHandlerFactory: IRequestHandlerFactory | null) {\r\n\t\tthis._requestHandlerFactory = requestHandlerFactory;\r\n\t\tthis._requestHandler = null;\r\n\t\tthis._protocol = new SimpleWorkerProtocol({\r\n\t\t\tsendMessage: (msg: any, transfer: ArrayBuffer[]): void => {\r\n\t\t\t\tpostMessage(msg, transfer);\r\n\t\t\t},\r\n\t\t\thandleMessage: (channel: string, method: string, args: any[]): Promise<any> => this._handleMessage(channel, method, args),\r\n\t\t\thandleEvent: (channel: string, eventName: string, arg: any): Event<any> => this._handleEvent(channel, eventName, arg)\r\n\t\t});\r\n\t}\r\n\r\n\tpublic onmessage(msg: any): void {\r\n\t\tthis._protocol.handleMessage(msg);\r\n\t}\r\n\r\n\tprivate _handleMessage(channel: string, method: string, args: any[]): Promise<any> {\r\n\t\tif (channel === DEFAULT_CHANNEL && method === INITIALIZE) {\r\n\t\t\treturn this.initialize(<number>args[0], <any>args[1], <string>args[2]);\r\n\t\t}\r\n\r\n\t\tconst requestHandler: object | null | undefined = (channel === DEFAULT_CHANNEL ? this._requestHandler : this._localChannels.get(channel));\r\n\t\tif (!requestHandler) {\r\n\t\t\treturn Promise.reject(new Error(`Missing channel ${channel} on worker thread`));\r\n\t\t}\r\n\t\tif (typeof (requestHandler as any)[method] !== 'function') {\r\n\t\t\treturn Promise.reject(new Error(`Missing method ${method} on worker thread channel ${channel}`));\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\treturn Promise.resolve((requestHandler as any)[method].apply(requestHandler, args));\r\n\t\t} catch (e) {\r\n\t\t\treturn Promise.reject(e);\r\n\t\t}\r\n\t}\r\n\r\n\tprivate _handleEvent(channel: string, eventName: string, arg: any): Event<any> {\r\n\t\tconst requestHandler: object | null | undefined = (channel === DEFAULT_CHANNEL ? this._requestHandler : this._localChannels.get(channel));\r\n\t\tif (!requestHandler) {\r\n\t\t\tthrow new Error(`Missing channel ${channel} on worker thread`);\r\n\t\t}\r\n\t\tif (propertyIsDynamicEvent(eventName)) {\r\n\t\t\tconst event = (requestHandler as any)[eventName].call(requestHandler, arg);\r\n\t\t\tif (typeof event !== 'function') {\r\n\t\t\t\tthrow new Error(`Missing dynamic event ${eventName} on request handler.`);\r\n\t\t\t}\r\n\t\t\treturn event;\r\n\t\t}\r\n\t\tif (propertyIsEvent(eventName)) {\r\n\t\t\tconst event = (requestHandler as any)[eventName];\r\n\t\t\tif (typeof event !== 'function') {\r\n\t\t\t\tthrow new Error(`Missing event ${eventName} on request handler.`);\r\n\t\t\t}\r\n\t\t\treturn event;\r\n\t\t}\r\n\t\tthrow new Error(`Malformed event name ${eventName}`);\r\n\t}\r\n\r\n\tpublic getChannel<T extends object>(channel: string): Proxied<T> {\r\n\t\tif (!this._remoteChannels.has(channel)) {\r\n\t\t\tconst inst = this._protocol.createProxyToRemoteChannel(channel);\r\n\t\t\tthis._remoteChannels.set(channel, inst);\r\n\t\t}\r\n\t\treturn this._remoteChannels.get(channel) as Proxied<T>;\r\n\t}\r\n\r\n\tprivate async initialize(workerId: number, loaderConfig: any, moduleId: string): Promise<void> {\r\n\t\tthis._protocol.setWorkerId(workerId);\r\n\r\n\t\tif (this._requestHandlerFactory) {\r\n\t\t\t// static request handler\r\n\t\t\tthis._requestHandler = this._requestHandlerFactory(this);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (loaderConfig) {\r\n\t\t\t// Remove 'baseUrl', handling it is beyond scope for now\r\n\t\t\tif (typeof loaderConfig.baseUrl !== 'undefined') {\r\n\t\t\t\tdelete loaderConfig['baseUrl'];\r\n\t\t\t}\r\n\t\t\tif (typeof loaderConfig.paths !== 'undefined') {\r\n\t\t\t\tif (typeof loaderConfig.paths.vs !== 'undefined') {\r\n\t\t\t\t\tdelete loaderConfig.paths['vs'];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (typeof loaderConfig.trustedTypesPolicy !== 'undefined') {\r\n\t\t\t\t// don't use, it has been destroyed during serialize\r\n\t\t\t\tdelete loaderConfig['trustedTypesPolicy'];\r\n\t\t\t}\r\n\r\n\t\t\t// Since this is in a web worker, enable catching errors\r\n\t\t\tloaderConfig.catchError = true;\r\n\t\t\t(globalThis as any).require.config(loaderConfig);\r\n\t\t}\r\n\r\n\t\tconst url = FileAccess.asBrowserUri(`${moduleId}.js` as AppResourcePath).toString(true);\r\n\t\treturn import(`${url}`).then((module: { create: IRequestHandlerFactory }) => {\r\n\t\t\tthis._requestHandler = module.create(this);\r\n\r\n\t\t\tif (!this._requestHandler) {\r\n\t\t\t\tthrow new Error(`No RequestHandler!`);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}\r\n\r\n/**\r\n * Defines the worker entry point. Must be exported and named `create`.\r\n * @skipMangle\r\n */\r\nexport function create(postMessage: (msg: Message, transfer?: ArrayBuffer[]) => void): SimpleWorkerServer {\r\n\treturn new SimpleWorkerServer(postMessage, null);\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nimport { CharCode } from '../charCode.js';\r\nimport { onUnexpectedError, transformErrorForSerialization } from '../errors.js';\r\nimport { Emitter, Event } from '../event.js';\r\nimport { Disposable, IDisposable } from '../lifecycle.js';\r\nimport { AppResourcePath, FileAccess } from '../network.js';\r\nimport { isWeb } from '../platform.js';\r\nimport * as strings from '../strings.js';\r\nimport { URI } from '../uri.js';\r\n\r\nconst DEFAULT_CHANNEL = 'default';\r\nconst INITIALIZE = '$initialize';\r\n\r\nexport interface IWorker extends IDisposable {\r\n\tgetId(): number;\r\n\tpostMessage(message: Message, transfer: ArrayBuffer[]): void;\r\n}\r\n\r\nexport interface IWorkerCallback {\r\n\t(message: Message): void;\r\n}\r\n\r\nexport interface IWorkerFactory {\r\n\tcreate(modules: IWorkerDescriptor, callback: IWorkerCallback, onErrorCallback: (err: any) => void): IWorker;\r\n}\r\n\r\nexport interface IWorkerDescriptor {\r\n\treadonly moduleId: string;\r\n\treadonly esmModuleLocation: URI | undefined;\r\n\treadonly label: string | undefined;\r\n}\r\n\r\nlet webWorkerWarningLogged = false;\r\nexport function logOnceWebWorkerWarning(err: any): void {\r\n\tif (!isWeb) {\r\n\t\t// running tests\r\n\t\treturn;\r\n\t}\r\n\tif (!webWorkerWarningLogged) {\r\n\t\twebWorkerWarningLogged = true;\r\n\t\tconsole.warn('Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq');\r\n\t}\r\n\tconsole.warn(err.message);\r\n}\r\n\r\nconst enum MessageType {\r\n\tRequest,\r\n\tReply,\r\n\tSubscribeEvent,\r\n\tEvent,\r\n\tUnsubscribeEvent\r\n}\r\nclass RequestMessage {\r\n\tpublic readonly type = MessageType.Request;\r\n\tconstructor(\r\n\t\tpublic readonly vsWorker: number,\r\n\t\tpublic readonly req: string,\r\n\t\tpublic readonly channel: string,\r\n\t\tpublic readonly method: string,\r\n\t\tpublic readonly args: any[]\r\n\t) { }\r\n}\r\nclass ReplyMessage {\r\n\tpublic readonly type = MessageType.Reply;\r\n\tconstructor(\r\n\t\tpublic readonly vsWorker: number,\r\n\t\tpublic readonly seq: string,\r\n\t\tpublic readonly res: any,\r\n\t\tpublic readonly err: any\r\n\t) { }\r\n}\r\nclass SubscribeEventMessage {\r\n\tpublic readonly type = MessageType.SubscribeEvent;\r\n\tconstructor(\r\n\t\tpublic readonly vsWorker: number,\r\n\t\tpublic readonly req: string,\r\n\t\tpublic readonly channel: string,\r\n\t\tpublic readonly eventName: string,\r\n\t\tpublic readonly arg: any\r\n\t) { }\r\n}\r\nclass EventMessage {\r\n\tpublic readonly type = MessageType.Event;\r\n\tconstructor(\r\n\t\tpublic readonly vsWorker: number,\r\n\t\tpublic readonly req: string,\r\n\t\tpublic readonly event: any\r\n\t) { }\r\n}\r\nclass UnsubscribeEventMessage {\r\n\tpublic readonly type = MessageType.UnsubscribeEvent;\r\n\tconstructor(\r\n\t\tpublic readonly vsWorker: number,\r\n\t\tpublic readonly req: string\r\n\t) { }\r\n}\r\ntype Message = RequestMessage | ReplyMessage | SubscribeEventMessage | EventMessage | UnsubscribeEventMessage;\r\n\r\ninterface IMessageReply {\r\n\tresolve: (value?: any) => void;\r\n\treject: (error?: any) => void;\r\n}\r\n\r\ninterface IMessageHandler {\r\n\tsendMessage(msg: any, transfer?: ArrayBuffer[]): void;\r\n\thandleMessage(channel: string, method: string, args: any[]): Promise<any>;\r\n\thandleEvent(channel: string, eventName: string, arg: any): Event<any>;\r\n}\r\n\r\nclass SimpleWorkerProtocol {\r\n\r\n\tprivate _workerId: number;\r\n\tprivate _lastSentReq: number;\r\n\tprivate _pendingReplies: { [req: string]: IMessageReply };\r\n\tprivate _pendingEmitters: Map<string, Emitter<any>>;\r\n\tprivate _pendingEvents: Map<string, IDisposable>;\r\n\tprivate _handler: IMessageHandler;\r\n\r\n\tconstructor(handler: IMessageHandler) {\r\n\t\tthis._workerId = -1;\r\n\t\tthis._handler = handler;\r\n\t\tthis._lastSentReq = 0;\r\n\t\tthis._pendingReplies = Object.create(null);\r\n\t\tthis._pendingEmitters = new Map<string, Emitter<any>>();\r\n\t\tthis._pendingEvents = new Map<string, IDisposable>();\r\n\t}\r\n\r\n\tpublic setWorkerId(workerId: number): void {\r\n\t\tthis._workerId = workerId;\r\n\t}\r\n\r\n\tpublic sendMessage(channel: string, method: string, args: any[]): Promise<any> {\r\n\t\tconst req = String(++this._lastSentReq);\r\n\t\treturn new Promise<any>((resolve, reject) => {\r\n\t\t\tthis._pendingReplies[req] = {\r\n\t\t\t\tresolve: resolve,\r\n\t\t\t\treject: reject\r\n\t\t\t};\r\n\t\t\tthis._send(new RequestMessage(this._workerId, req, channel, method, args));\r\n\t\t});\r\n\t}\r\n\r\n\tpublic listen(channel: string, eventName: string, arg: any): Event<any> {\r\n\t\tlet req: string | null = null;\r\n\t\tconst emitter = new Emitter<any>({\r\n\t\t\tonWillAddFirstListener: () => {\r\n\t\t\t\treq = String(++this._lastSentReq);\r\n\t\t\t\tthis._pendingEmitters.set(req, emitter);\r\n\t\t\t\tthis._send(new SubscribeEventMessage(this._workerId, req, channel, eventName, arg));\r\n\t\t\t},\r\n\t\t\tonDidRemoveLastListener: () => {\r\n\t\t\t\tthis._pendingEmitters.delete(req!);\r\n\t\t\t\tthis._send(new UnsubscribeEventMessage(this._workerId, req!));\r\n\t\t\t\treq = null;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn emitter.event;\r\n\t}\r\n\r\n\tpublic handleMessage(message: Message): void {\r\n\t\tif (!message || !message.vsWorker) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (this._workerId !== -1 && message.vsWorker !== this._workerId) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis._handleMessage(message);\r\n\t}\r\n\r\n\tpublic createProxyToRemoteChannel<T extends object>(channel: string, sendMessageBarrier?: () => Promise<void>): T {\r\n\t\tconst handler = {\r\n\t\t\tget: (target: any, name: PropertyKey) => {\r\n\t\t\t\tif (typeof name === 'string' && !target[name]) {\r\n\t\t\t\t\tif (propertyIsDynamicEvent(name)) { // onDynamic...\r\n\t\t\t\t\t\ttarget[name] = (arg: any): Event<any> => {\r\n\t\t\t\t\t\t\treturn this.listen(channel, name, arg);\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t} else if (propertyIsEvent(name)) { // on...\r\n\t\t\t\t\t\ttarget[name] = this.listen(channel, name, undefined);\r\n\t\t\t\t\t} else if (name.charCodeAt(0) === CharCode.DollarSign) { // $...\r\n\t\t\t\t\t\ttarget[name] = async (...myArgs: any[]) => {\r\n\t\t\t\t\t\t\tawait sendMessageBarrier?.();\r\n\t\t\t\t\t\t\treturn this.sendMessage(channel, name, myArgs);\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn target[name];\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn new Proxy(Object.create(null), handler);\r\n\t}\r\n\r\n\tprivate _handleMessage(msg: Message): void {\r\n\t\tswitch (msg.type) {\r\n\t\t\tcase MessageType.Reply:\r\n\t\t\t\treturn this._handleReplyMessage(msg);\r\n\t\t\tcase MessageType.Request:\r\n\t\t\t\treturn this._handleRequestMessage(msg);\r\n\t\t\tcase MessageType.SubscribeEvent:\r\n\t\t\t\treturn this._handleSubscribeEventMessage(msg);\r\n\t\t\tcase MessageType.Event:\r\n\t\t\t\treturn this._handleEventMessage(msg);\r\n\t\t\tcase MessageType.UnsubscribeEvent:\r\n\t\t\t\treturn this._handleUnsubscribeEventMessage(msg);\r\n\t\t}\r\n\t}\r\n\r\n\tprivate _handleReplyMessage(replyMessage: ReplyMessage): void {\r\n\t\tif (!this._pendingReplies[replyMessage.seq]) {\r\n\t\t\tconsole.warn('Got reply to unknown seq');\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst reply = this._pendingReplies[replyMessage.seq];\r\n\t\tdelete this._pendingReplies[replyMessage.seq];\r\n\r\n\t\tif (replyMessage.err) {\r\n\t\t\tlet err = replyMessage.err;\r\n\t\t\tif (replyMessage.err.$isError) {\r\n\t\t\t\terr = new Error();\r\n\t\t\t\terr.name = replyMessage.err.name;\r\n\t\t\t\terr.message = replyMessage.err.message;\r\n\t\t\t\terr.stack = replyMessage.err.stack;\r\n\t\t\t}\r\n\t\t\treply.reject(err);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\treply.resolve(replyMessage.res);\r\n\t}\r\n\r\n\tprivate _handleRequestMessage(requestMessage: RequestMessage): void {\r\n\t\tconst req = requestMessage.req;\r\n\t\tconst result = this._handler.handleMessage(requestMessage.channel, requestMessage.method, requestMessage.args);\r\n\t\tresult.then((r) => {\r\n\t\t\tthis._send(new ReplyMessage(this._workerId, req, r, undefined));\r\n\t\t}, (e) => {\r\n\t\t\tif (e.detail instanceof Error) {\r\n\t\t\t\t// Loading errors have a detail property that points to the actual error\r\n\t\t\t\te.detail = transformErrorForSerialization(e.detail);\r\n\t\t\t}\r\n\t\t\tthis._send(new ReplyMessage(this._workerId, req, undefined, transformErrorForSerialization(e)));\r\n\t\t});\r\n\t}\r\n\r\n\tprivate _handleSubscribeEventMessage(msg: SubscribeEventMessage): void {\r\n\t\tconst req = msg.req;\r\n\t\tconst disposable = this._handler.handleEvent(msg.channel, msg.eventName, msg.arg)((event) => {\r\n\t\t\tthis._send(new EventMessage(this._workerId, req, event));\r\n\t\t});\r\n\t\tthis._pendingEvents.set(req, disposable);\r\n\t}\r\n\r\n\tprivate _handleEventMessage(msg: EventMessage): void {\r\n\t\tif (!this._pendingEmitters.has(msg.req)) {\r\n\t\t\tconsole.warn('Got event for unknown req');\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis._pendingEmitters.get(msg.req)!.fire(msg.event);\r\n\t}\r\n\r\n\tprivate _handleUnsubscribeEventMessage(msg: UnsubscribeEventMessage): void {\r\n\t\tif (!this._pendingEvents.has(msg.req)) {\r\n\t\t\tconsole.warn('Got unsubscribe for unknown req');\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis._pendingEvents.get(msg.req)!.dispose();\r\n\t\tthis._pendingEvents.delete(msg.req);\r\n\t}\r\n\r\n\tprivate _send(msg: Message): void {\r\n\t\tconst transfer: ArrayBuffer[] = [];\r\n\t\tif (msg.type === MessageType.Request) {\r\n\t\t\tfor (let i = 0; i < msg.args.length; i++) {\r\n\t\t\t\tif (msg.args[i] instanceof ArrayBuffer) {\r\n\t\t\t\t\ttransfer.push(msg.args[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (msg.type === MessageType.Reply) {\r\n\t\t\tif (msg.res instanceof ArrayBuffer) {\r\n\t\t\t\ttransfer.push(msg.res);\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis._handler.sendMessage(msg, transfer);\r\n\t}\r\n}\r\n\r\ntype ProxiedMethodName = (`$${string}` | `on${string}`);\r\n\r\nexport type Proxied<T> = { [K in keyof T]: T[K] extends (...args: infer A) => infer R\r\n\t? (\r\n\t\tK extends ProxiedMethodName\r\n\t\t? (...args: A) => Promise<Awaited<R>>\r\n\t\t: never\r\n\t)\r\n\t: never\r\n};\r\n\r\nexport interface IWorkerClient<W> {\r\n\tproxy: Proxied<W>;\r\n\tdispose(): void;\r\n\tsetChannel<T extends object>(channel: string, handler: T): void;\r\n}\r\n\r\nexport interface IWorkerServer {\r\n\tgetChannel<T extends object>(channel: string): Proxied<T>;\r\n}\r\n\r\n/**\r\n * Main thread side\r\n */\r\nexport class SimpleWorkerClient<W extends object> extends Disposable implements IWorkerClient<W> {\r\n\r\n\tprivate readonly _worker: IWorker;\r\n\tprivate readonly _onModuleLoaded: Promise<void>;\r\n\tprivate readonly _protocol: SimpleWorkerProtocol;\r\n\tpublic readonly proxy: Proxied<W>;\r\n\tprivate readonly _localChannels: Map<string, object> = new Map();\r\n\r\n\tconstructor(\r\n\t\tworkerFactory: IWorkerFactory,\r\n\t\tworkerDescriptor: IWorkerDescriptor,\r\n\t) {\r\n\t\tsuper();\r\n\r\n\t\tthis._worker = this._register(workerFactory.create(\r\n\t\t\t{\r\n\t\t\t\tmoduleId: 'vs/base/common/worker/simpleWorker',\r\n\t\t\t\tesmModuleLocation: workerDescriptor.esmModuleLocation,\r\n\t\t\t\tlabel: workerDescriptor.label\r\n\t\t\t},\r\n\t\t\t(msg: Message) => {\r\n\t\t\t\tthis._protocol.handleMessage(msg);\r\n\t\t\t},\r\n\t\t\t(err: any) => {\r\n\t\t\t\t// in Firefox, web workers fail lazily :(\r\n\t\t\t\t// we will reject the proxy\r\n\t\t\t\tonUnexpectedError(err);\r\n\t\t\t}\r\n\t\t));\r\n\r\n\t\tthis._protocol = new SimpleWorkerProtocol({\r\n\t\t\tsendMessage: (msg: any, transfer: ArrayBuffer[]): void => {\r\n\t\t\t\tthis._worker.postMessage(msg, transfer);\r\n\t\t\t},\r\n\t\t\thandleMessage: (channel: string, method: string, args: any[]): Promise<any> => {\r\n\t\t\t\treturn this._handleMessage(channel, method, args);\r\n\t\t\t},\r\n\t\t\thandleEvent: (channel: string, eventName: string, arg: any): Event<any> => {\r\n\t\t\t\treturn this._handleEvent(channel, eventName, arg);\r\n\t\t\t}\r\n\t\t});\r\n\t\tthis._protocol.setWorkerId(this._worker.getId());\r\n\r\n\t\t// Gather loader configuration\r\n\t\tlet loaderConfiguration: any = null;\r\n\r\n\t\tconst globalRequire: { getConfig?(): object } | undefined = (globalThis as any).require;\r\n\t\tif (typeof globalRequire !== 'undefined' && typeof globalRequire.getConfig === 'function') {\r\n\t\t\t// Get the configuration from the Monaco AMD Loader\r\n\t\t\tloaderConfiguration = globalRequire.getConfig();\r\n\t\t} else if (typeof (globalThis as any).requirejs !== 'undefined') {\r\n\t\t\t// Get the configuration from requirejs\r\n\t\t\tloaderConfiguration = (globalThis as any).requirejs.s.contexts._.config;\r\n\t\t}\r\n\r\n\t\t// Send initialize message\r\n\t\tthis._onModuleLoaded = this._protocol.sendMessage(DEFAULT_CHANNEL, INITIALIZE, [\r\n\t\t\tthis._worker.getId(),\r\n\t\t\tJSON.parse(JSON.stringify(loaderConfiguration)),\r\n\t\t\tworkerDescriptor.moduleId,\r\n\t\t]);\r\n\r\n\t\tthis.proxy = this._protocol.createProxyToRemoteChannel(DEFAULT_CHANNEL, async () => { await this._onModuleLoaded; });\r\n\t\tthis._onModuleLoaded.catch((e) => {\r\n\t\t\tthis._onError('Worker failed to load ' + workerDescriptor.moduleId, e);\r\n\t\t});\r\n\t}\r\n\r\n\tprivate _handleMessage(channelName: string, method: string, args: any[]): Promise<any> {\r\n\t\tconst channel: object | undefined = this._localChannels.get(channelName);\r\n\t\tif (!channel) {\r\n\t\t\treturn Promise.reject(new Error(`Missing channel ${channelName} on main thread`));\r\n\t\t}\r\n\t\tif (typeof (channel as any)[method] !== 'function') {\r\n\t\t\treturn Promise.reject(new Error(`Missing method ${method} on main thread channel ${channelName}`));\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\treturn Promise.resolve((channel as any)[method].apply(channel, args));\r\n\t\t} catch (e) {\r\n\t\t\treturn Promise.reject(e);\r\n\t\t}\r\n\t}\r\n\r\n\tprivate _handleEvent(channelName: string, eventName: string, arg: any): Event<any> {\r\n\t\tconst channel: object | undefined = this._localChannels.get(channelName);\r\n\t\tif (!channel) {\r\n\t\t\tthrow new Error(`Missing channel ${channelName} on main thread`);\r\n\t\t}\r\n\t\tif (propertyIsDynamicEvent(eventName)) {\r\n\t\t\tconst event = (channel as any)[eventName].call(channel, arg);\r\n\t\t\tif (typeof event !== 'function') {\r\n\t\t\t\tthrow new Error(`Missing dynamic event ${eventName} on main thread channel ${channelName}.`);\r\n\t\t\t}\r\n\t\t\treturn event;\r\n\t\t}\r\n\t\tif (propertyIsEvent(eventName)) {\r\n\t\t\tconst event = (channel as any)[eventName];\r\n\t\t\tif (typeof event !== 'function') {\r\n\t\t\t\tthrow new Error(`Missing event ${eventName} on main thread channel ${channelName}.`);\r\n\t\t\t}\r\n\t\t\treturn event;\r\n\t\t}\r\n\t\tthrow new Error(`Malformed event name ${eventName}`);\r\n\t}\r\n\r\n\tpublic setChannel<T extends object>(channel: string, handler: T): void {\r\n\t\tthis._localChannels.set(channel, handler);\r\n\t}\r\n\r\n\tprivate _onError(message: string, error?: any): void {\r\n\t\tconsole.error(message);\r\n\t\tconsole.info(error);\r\n\t}\r\n}\r\n\r\nfunction propertyIsEvent(name: string): boolean {\r\n\t// Assume a property is an event if it has a form of \"onSomething\"\r\n\treturn name[0] === 'o' && name[1] === 'n' && strings.isUpperAsciiLetter(name.charCodeAt(2));\r\n}\r\n\r\nfunction propertyIsDynamicEvent(name: string): boolean {\r\n\t// Assume a property is a dynamic event (a method that returns an event) if it has a form of \"onDynamicSomething\"\r\n\treturn /^onDynamic/.test(name) && strings.isUpperAsciiLetter(name.charCodeAt(9));\r\n}\r\n\r\nexport interface IRequestHandler {\r\n\t_requestHandlerBrand: any;\r\n\t[prop: string]: any;\r\n}\r\n\r\nexport interface IRequestHandlerFactory {\r\n\t(workerServer: IWorkerServer): IRequestHandler;\r\n}\r\n\r\n/**\r\n * Worker side\r\n */\r\nexport class SimpleWorkerServer implements IWorkerServer {\r\n\r\n\tprivate _requestHandlerFactory: IRequestHandlerFactory | null;\r\n\tprivate _requestHandler: IRequestHandler | null;\r\n\tprivate _protocol: SimpleWorkerProtocol;\r\n\tprivate readonly _localChannels: Map<string, object> = new Map();\r\n\tprivate readonly _remoteChannels: Map<string, object> = new Map();\r\n\r\n\tconstructor(postMessage: (msg: Message, transfer?: ArrayBuffer[]) => void, requestHandlerFactory: IRequestHandlerFactory | null) {\r\n\t\tthis._requestHandlerFactory = requestHandlerFactory;\r\n\t\tthis._requestHandler = null;\r\n\t\tthis._protocol = new SimpleWorkerProtocol({\r\n\t\t\tsendMessage: (msg: any, transfer: ArrayBuffer[]): void => {\r\n\t\t\t\tpostMessage(msg, transfer);\r\n\t\t\t},\r\n\t\t\thandleMessage: (channel: string, method: string, args: any[]): Promise<any> => this._handleMessage(channel, method, args),\r\n\t\t\thandleEvent: (channel: string, eventName: string, arg: any): Event<any> => this._handleEvent(channel, eventName, arg)\r\n\t\t});\r\n\t}\r\n\r\n\tpublic onmessage(msg: any): void {\r\n\t\tthis._protocol.handleMessage(msg);\r\n\t}\r\n\r\n\tprivate _handleMessage(channel: string, method: string, args: any[]): Promise<any> {\r\n\t\tif (channel === DEFAULT_CHANNEL && method === INITIALIZE) {\r\n\t\t\treturn this.initialize(<number>args[0], <any>args[1], <string>args[2]);\r\n\t\t}\r\n\r\n\t\tconst requestHandler: object | null | undefined = (channel === DEFAULT_CHANNEL ? this._requestHandler : this._localChannels.get(channel));\r\n\t\tif (!requestHandler) {\r\n\t\t\treturn Promise.reject(new Error(`Missing channel ${channel} on worker thread`));\r\n\t\t}\r\n\t\tif (typeof (requestHandler as any)[method] !== 'function') {\r\n\t\t\treturn Promise.reject(new Error(`Missing method ${method} on worker thread channel ${channel}`));\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\treturn Promise.resolve((requestHandler as any)[method].apply(requestHandler, args));\r\n\t\t} catch (e) {\r\n\t\t\treturn Promise.reject(e);\r\n\t\t}\r\n\t}\r\n\r\n\tprivate _handleEvent(channel: string, eventName: string, arg: any): Event<any> {\r\n\t\tconst requestHandler: object | null | undefined = (channel === DEFAULT_CHANNEL ? this._requestHandler : this._localChannels.get(channel));\r\n\t\tif (!requestHandler) {\r\n\t\t\tthrow new Error(`Missing channel ${channel} on worker thread`);\r\n\t\t}\r\n\t\tif (propertyIsDynamicEvent(eventName)) {\r\n\t\t\tconst event = (requestHandler as any)[eventName].call(requestHandler, arg);\r\n\t\t\tif (typeof event !== 'function') {\r\n\t\t\t\tthrow new Error(`Missing dynamic event ${eventName} on request handler.`);\r\n\t\t\t}\r\n\t\t\treturn event;\r\n\t\t}\r\n\t\tif (propertyIsEvent(eventName)) {\r\n\t\t\tconst event = (requestHandler as any)[eventName];\r\n\t\t\tif (typeof event !== 'function') {\r\n\t\t\t\tthrow new Error(`Missing event ${eventName} on request handler.`);\r\n\t\t\t}\r\n\t\t\treturn event;\r\n\t\t}\r\n\t\tthrow new Error(`Malformed event name ${eventName}`);\r\n\t}\r\n\r\n\tpublic getChannel<T extends object>(channel: string): Proxied<T> {\r\n\t\tif (!this._remoteChannels.has(channel)) {\r\n\t\t\tconst inst = this._protocol.createProxyToRemoteChannel(channel);\r\n\t\t\tthis._remoteChannels.set(channel, inst);\r\n\t\t}\r\n\t\treturn this._remoteChannels.get(channel) as Proxied<T>;\r\n\t}\r\n\r\n\tprivate async initialize(workerId: number, loaderConfig: any, moduleId: string): Promise<void> {\r\n\t\tthis._protocol.setWorkerId(workerId);\r\n\r\n\t\tif (this._requestHandlerFactory) {\r\n\t\t\t// static request handler\r\n\t\t\tthis._requestHandler = this._requestHandlerFactory(this);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (loaderConfig) {\r\n\t\t\t// Remove 'baseUrl', handling it is beyond scope for now\r\n\t\t\tif (typeof loaderConfig.baseUrl !== 'undefined') {\r\n\t\t\t\tdelete loaderConfig['baseUrl'];\r\n\t\t\t}\r\n\t\t\tif (typeof loaderConfig.paths !== 'undefined') {\r\n\t\t\t\tif (typeof loaderConfig.paths.vs !== 'undefined') {\r\n\t\t\t\t\tdelete loaderConfig.paths['vs'];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (typeof loaderConfig.trustedTypesPolicy !== 'undefined') {\r\n\t\t\t\t// don't use, it has been destroyed during serialize\r\n\t\t\t\tdelete loaderConfig['trustedTypesPolicy'];\r\n\t\t\t}\r\n\r\n\t\t\t// Since this is in a web worker, enable catching errors\r\n\t\t\tloaderConfig.catchError = true;\r\n\t\t\t(globalThis as any).require.config(loaderConfig);\r\n\t\t}\r\n\r\n\t\tconst url = FileAccess.asBrowserUri(`${moduleId}.js` as AppResourcePath).toString(true);\r\n\t\treturn import(`${url}`).then((module: { create: IRequestHandlerFactory }) => {\r\n\t\t\tthis._requestHandler = module.create(this);\r\n\r\n\t\t\tif (!this._requestHandler) {\r\n\t\t\t\tthrow new Error(`No RequestHandler!`);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}\r\n\r\n/**\r\n * Defines the worker entry point. Must be exported and named `create`.\r\n * @skipMangle\r\n */\r\nexport function create(postMessage: (msg: Message, transfer?: ArrayBuffer[]) => void): SimpleWorkerServer {\r\n\treturn new SimpleWorkerServer(postMessage, null);\r\n}\r\n"],"mappings":"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","names":["require"],"file":"workerMain.js"}