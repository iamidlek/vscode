{"version":3,"sources":["./file:/Users/iamidlek/Desktop/mantech/vscode/out-editor-src/vs/base/common/worker/simpleWorker.ts","vs/base/common/worker/simpleWorker.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nimport { CharCode } from '../charCode.js';\r\nimport { onUnexpectedError, transformErrorForSerialization } from '../errors.js';\r\nimport { Emitter, Event } from '../event.js';\r\nimport { Disposable, IDisposable } from '../lifecycle.js';\r\nimport { AppResourcePath, FileAccess } from '../network.js';\r\nimport { isWeb } from '../platform.js';\r\nimport * as strings from '../strings.js';\r\nimport { URI } from '../uri.js';\r\n\r\nconst DEFAULT_CHANNEL = 'default';\r\nconst INITIALIZE = '$initialize';\r\n\r\nexport interface IWorker extends IDisposable {\r\n\tgetId(): number;\r\n\tpostMessage(message: Message, transfer: ArrayBuffer[]): void;\r\n}\r\n\r\nexport interface IWorkerCallback {\r\n\t(message: Message): void;\r\n}\r\n\r\nexport interface IWorkerFactory {\r\n\tcreate(modules: IWorkerDescriptor, callback: IWorkerCallback, onErrorCallback: (err: any) => void): IWorker;\r\n}\r\n\r\nexport interface IWorkerDescriptor {\r\n\treadonly moduleId: string;\r\n\treadonly esmModuleLocation: URI | undefined;\r\n\treadonly label: string | undefined;\r\n}\r\n\r\nlet webWorkerWarningLogged = false;\r\nexport function logOnceWebWorkerWarning(err: any): void {\r\n\tif (!isWeb) {\r\n\t\t// running tests\r\n\t\treturn;\r\n\t}\r\n\tif (!webWorkerWarningLogged) {\r\n\t\twebWorkerWarningLogged = true;\r\n\t\tconsole.warn('Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq');\r\n\t}\r\n\tconsole.warn(err.message);\r\n}\r\n\r\nconst enum MessageType {\r\n\tRequest,\r\n\tReply,\r\n\tSubscribeEvent,\r\n\tEvent,\r\n\tUnsubscribeEvent\r\n}\r\nclass RequestMessage {\r\n\tpublic readonly type = MessageType.Request;\r\n\tconstructor(\r\n\t\tpublic readonly vsWorker: number,\r\n\t\tpublic readonly req: string,\r\n\t\tpublic readonly channel: string,\r\n\t\tpublic readonly method: string,\r\n\t\tpublic readonly args: any[]\r\n\t) { }\r\n}\r\nclass ReplyMessage {\r\n\tpublic readonly type = MessageType.Reply;\r\n\tconstructor(\r\n\t\tpublic readonly vsWorker: number,\r\n\t\tpublic readonly seq: string,\r\n\t\tpublic readonly res: any,\r\n\t\tpublic readonly err: any\r\n\t) { }\r\n}\r\nclass SubscribeEventMessage {\r\n\tpublic readonly type = MessageType.SubscribeEvent;\r\n\tconstructor(\r\n\t\tpublic readonly vsWorker: number,\r\n\t\tpublic readonly req: string,\r\n\t\tpublic readonly channel: string,\r\n\t\tpublic readonly eventName: string,\r\n\t\tpublic readonly arg: any\r\n\t) { }\r\n}\r\nclass EventMessage {\r\n\tpublic readonly type = MessageType.Event;\r\n\tconstructor(\r\n\t\tpublic readonly vsWorker: number,\r\n\t\tpublic readonly req: string,\r\n\t\tpublic readonly event: any\r\n\t) { }\r\n}\r\nclass UnsubscribeEventMessage {\r\n\tpublic readonly type = MessageType.UnsubscribeEvent;\r\n\tconstructor(\r\n\t\tpublic readonly vsWorker: number,\r\n\t\tpublic readonly req: string\r\n\t) { }\r\n}\r\ntype Message = RequestMessage | ReplyMessage | SubscribeEventMessage | EventMessage | UnsubscribeEventMessage;\r\n\r\ninterface IMessageReply {\r\n\tresolve: (value?: any) => void;\r\n\treject: (error?: any) => void;\r\n}\r\n\r\ninterface IMessageHandler {\r\n\tsendMessage(msg: any, transfer?: ArrayBuffer[]): void;\r\n\thandleMessage(channel: string, method: string, args: any[]): Promise<any>;\r\n\thandleEvent(channel: string, eventName: string, arg: any): Event<any>;\r\n}\r\n\r\nclass SimpleWorkerProtocol {\r\n\r\n\tprivate _workerId: number;\r\n\tprivate _lastSentReq: number;\r\n\tprivate _pendingReplies: { [req: string]: IMessageReply };\r\n\tprivate _pendingEmitters: Map<string, Emitter<any>>;\r\n\tprivate _pendingEvents: Map<string, IDisposable>;\r\n\tprivate _handler: IMessageHandler;\r\n\r\n\tconstructor(handler: IMessageHandler) {\r\n\t\tthis._workerId = -1;\r\n\t\tthis._handler = handler;\r\n\t\tthis._lastSentReq = 0;\r\n\t\tthis._pendingReplies = Object.create(null);\r\n\t\tthis._pendingEmitters = new Map<string, Emitter<any>>();\r\n\t\tthis._pendingEvents = new Map<string, IDisposable>();\r\n\t}\r\n\r\n\tpublic setWorkerId(workerId: number): void {\r\n\t\tthis._workerId = workerId;\r\n\t}\r\n\r\n\tpublic sendMessage(channel: string, method: string, args: any[]): Promise<any> {\r\n\t\tconst req = String(++this._lastSentReq);\r\n\t\treturn new Promise<any>((resolve, reject) => {\r\n\t\t\tthis._pendingReplies[req] = {\r\n\t\t\t\tresolve: resolve,\r\n\t\t\t\treject: reject\r\n\t\t\t};\r\n\t\t\tthis._send(new RequestMessage(this._workerId, req, channel, method, args));\r\n\t\t});\r\n\t}\r\n\r\n\tpublic listen(channel: string, eventName: string, arg: any): Event<any> {\r\n\t\tlet req: string | null = null;\r\n\t\tconst emitter = new Emitter<any>({\r\n\t\t\tonWillAddFirstListener: () => {\r\n\t\t\t\treq = String(++this._lastSentReq);\r\n\t\t\t\tthis._pendingEmitters.set(req, emitter);\r\n\t\t\t\tthis._send(new SubscribeEventMessage(this._workerId, req, channel, eventName, arg));\r\n\t\t\t},\r\n\t\t\tonDidRemoveLastListener: () => {\r\n\t\t\t\tthis._pendingEmitters.delete(req!);\r\n\t\t\t\tthis._send(new UnsubscribeEventMessage(this._workerId, req!));\r\n\t\t\t\treq = null;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn emitter.event;\r\n\t}\r\n\r\n\tpublic handleMessage(message: Message): void {\r\n\t\tif (!message || !message.vsWorker) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (this._workerId !== -1 && message.vsWorker !== this._workerId) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis._handleMessage(message);\r\n\t}\r\n\r\n\tpublic createProxyToRemoteChannel<T extends object>(channel: string, sendMessageBarrier?: () => Promise<void>): T {\r\n\t\tconst handler = {\r\n\t\t\tget: (target: any, name: PropertyKey) => {\r\n\t\t\t\tif (typeof name === 'string' && !target[name]) {\r\n\t\t\t\t\tif (propertyIsDynamicEvent(name)) { // onDynamic...\r\n\t\t\t\t\t\ttarget[name] = (arg: any): Event<any> => {\r\n\t\t\t\t\t\t\treturn this.listen(channel, name, arg);\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t} else if (propertyIsEvent(name)) { // on...\r\n\t\t\t\t\t\ttarget[name] = this.listen(channel, name, undefined);\r\n\t\t\t\t\t} else if (name.charCodeAt(0) === CharCode.DollarSign) { // $...\r\n\t\t\t\t\t\ttarget[name] = async (...myArgs: any[]) => {\r\n\t\t\t\t\t\t\tawait sendMessageBarrier?.();\r\n\t\t\t\t\t\t\treturn this.sendMessage(channel, name, myArgs);\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn target[name];\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn new Proxy(Object.create(null), handler);\r\n\t}\r\n\r\n\tprivate _handleMessage(msg: Message): void {\r\n\t\tswitch (msg.type) {\r\n\t\t\tcase MessageType.Reply:\r\n\t\t\t\treturn this._handleReplyMessage(msg);\r\n\t\t\tcase MessageType.Request:\r\n\t\t\t\treturn this._handleRequestMessage(msg);\r\n\t\t\tcase MessageType.SubscribeEvent:\r\n\t\t\t\treturn this._handleSubscribeEventMessage(msg);\r\n\t\t\tcase MessageType.Event:\r\n\t\t\t\treturn this._handleEventMessage(msg);\r\n\t\t\tcase MessageType.UnsubscribeEvent:\r\n\t\t\t\treturn this._handleUnsubscribeEventMessage(msg);\r\n\t\t}\r\n\t}\r\n\r\n\tprivate _handleReplyMessage(replyMessage: ReplyMessage): void {\r\n\t\tif (!this._pendingReplies[replyMessage.seq]) {\r\n\t\t\tconsole.warn('Got reply to unknown seq');\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst reply = this._pendingReplies[replyMessage.seq];\r\n\t\tdelete this._pendingReplies[replyMessage.seq];\r\n\r\n\t\tif (replyMessage.err) {\r\n\t\t\tlet err = replyMessage.err;\r\n\t\t\tif (replyMessage.err.$isError) {\r\n\t\t\t\terr = new Error();\r\n\t\t\t\terr.name = replyMessage.err.name;\r\n\t\t\t\terr.message = replyMessage.err.message;\r\n\t\t\t\terr.stack = replyMessage.err.stack;\r\n\t\t\t}\r\n\t\t\treply.reject(err);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\treply.resolve(replyMessage.res);\r\n\t}\r\n\r\n\tprivate _handleRequestMessage(requestMessage: RequestMessage): void {\r\n\t\tconst req = requestMessage.req;\r\n\t\tconst result = this._handler.handleMessage(requestMessage.channel, requestMessage.method, requestMessage.args);\r\n\t\tresult.then((r) => {\r\n\t\t\tthis._send(new ReplyMessage(this._workerId, req, r, undefined));\r\n\t\t}, (e) => {\r\n\t\t\tif (e.detail instanceof Error) {\r\n\t\t\t\t// Loading errors have a detail property that points to the actual error\r\n\t\t\t\te.detail = transformErrorForSerialization(e.detail);\r\n\t\t\t}\r\n\t\t\tthis._send(new ReplyMessage(this._workerId, req, undefined, transformErrorForSerialization(e)));\r\n\t\t});\r\n\t}\r\n\r\n\tprivate _handleSubscribeEventMessage(msg: SubscribeEventMessage): void {\r\n\t\tconst req = msg.req;\r\n\t\tconst disposable = this._handler.handleEvent(msg.channel, msg.eventName, msg.arg)((event) => {\r\n\t\t\tthis._send(new EventMessage(this._workerId, req, event));\r\n\t\t});\r\n\t\tthis._pendingEvents.set(req, disposable);\r\n\t}\r\n\r\n\tprivate _handleEventMessage(msg: EventMessage): void {\r\n\t\tif (!this._pendingEmitters.has(msg.req)) {\r\n\t\t\tconsole.warn('Got event for unknown req');\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis._pendingEmitters.get(msg.req)!.fire(msg.event);\r\n\t}\r\n\r\n\tprivate _handleUnsubscribeEventMessage(msg: UnsubscribeEventMessage): void {\r\n\t\tif (!this._pendingEvents.has(msg.req)) {\r\n\t\t\tconsole.warn('Got unsubscribe for unknown req');\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis._pendingEvents.get(msg.req)!.dispose();\r\n\t\tthis._pendingEvents.delete(msg.req);\r\n\t}\r\n\r\n\tprivate _send(msg: Message): void {\r\n\t\tconst transfer: ArrayBuffer[] = [];\r\n\t\tif (msg.type === MessageType.Request) {\r\n\t\t\tfor (let i = 0; i < msg.args.length; i++) {\r\n\t\t\t\tif (msg.args[i] instanceof ArrayBuffer) {\r\n\t\t\t\t\ttransfer.push(msg.args[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (msg.type === MessageType.Reply) {\r\n\t\t\tif (msg.res instanceof ArrayBuffer) {\r\n\t\t\t\ttransfer.push(msg.res);\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis._handler.sendMessage(msg, transfer);\r\n\t}\r\n}\r\n\r\ntype ProxiedMethodName = (`$${string}` | `on${string}`);\r\n\r\nexport type Proxied<T> = { [K in keyof T]: T[K] extends (...args: infer A) => infer R\r\n\t? (\r\n\t\tK extends ProxiedMethodName\r\n\t\t? (...args: A) => Promise<Awaited<R>>\r\n\t\t: never\r\n\t)\r\n\t: never\r\n};\r\n\r\nexport interface IWorkerClient<W> {\r\n\tproxy: Proxied<W>;\r\n\tdispose(): void;\r\n\tsetChannel<T extends object>(channel: string, handler: T): void;\r\n}\r\n\r\nexport interface IWorkerServer {\r\n\tgetChannel<T extends object>(channel: string): Proxied<T>;\r\n}\r\n\r\n/**\r\n * Main thread side\r\n */\r\nexport class SimpleWorkerClient<W extends object> extends Disposable implements IWorkerClient<W> {\r\n\r\n\tprivate readonly _worker: IWorker;\r\n\tprivate readonly _onModuleLoaded: Promise<void>;\r\n\tprivate readonly _protocol: SimpleWorkerProtocol;\r\n\tpublic readonly proxy: Proxied<W>;\r\n\tprivate readonly _localChannels: Map<string, object> = new Map();\r\n\r\n\tconstructor(\r\n\t\tworkerFactory: IWorkerFactory,\r\n\t\tworkerDescriptor: IWorkerDescriptor,\r\n\t) {\r\n\t\tsuper();\r\n\r\n\t\tthis._worker = this._register(workerFactory.create(\r\n\t\t\t{\r\n\t\t\t\tmoduleId: 'vs/base/common/worker/simpleWorker',\r\n\t\t\t\tesmModuleLocation: workerDescriptor.esmModuleLocation,\r\n\t\t\t\tlabel: workerDescriptor.label\r\n\t\t\t},\r\n\t\t\t(msg: Message) => {\r\n\t\t\t\tthis._protocol.handleMessage(msg);\r\n\t\t\t},\r\n\t\t\t(err: any) => {\r\n\t\t\t\t// in Firefox, web workers fail lazily :(\r\n\t\t\t\t// we will reject the proxy\r\n\t\t\t\tonUnexpectedError(err);\r\n\t\t\t}\r\n\t\t));\r\n\r\n\t\tthis._protocol = new SimpleWorkerProtocol({\r\n\t\t\tsendMessage: (msg: any, transfer: ArrayBuffer[]): void => {\r\n\t\t\t\tthis._worker.postMessage(msg, transfer);\r\n\t\t\t},\r\n\t\t\thandleMessage: (channel: string, method: string, args: any[]): Promise<any> => {\r\n\t\t\t\treturn this._handleMessage(channel, method, args);\r\n\t\t\t},\r\n\t\t\thandleEvent: (channel: string, eventName: string, arg: any): Event<any> => {\r\n\t\t\t\treturn this._handleEvent(channel, eventName, arg);\r\n\t\t\t}\r\n\t\t});\r\n\t\tthis._protocol.setWorkerId(this._worker.getId());\r\n\r\n\t\t// Gather loader configuration\r\n\t\tlet loaderConfiguration: any = null;\r\n\r\n\t\tconst globalRequire: { getConfig?(): object } | undefined = (globalThis as any).require;\r\n\t\tif (typeof globalRequire !== 'undefined' && typeof globalRequire.getConfig === 'function') {\r\n\t\t\t// Get the configuration from the Monaco AMD Loader\r\n\t\t\tloaderConfiguration = globalRequire.getConfig();\r\n\t\t} else if (typeof (globalThis as any).requirejs !== 'undefined') {\r\n\t\t\t// Get the configuration from requirejs\r\n\t\t\tloaderConfiguration = (globalThis as any).requirejs.s.contexts._.config;\r\n\t\t}\r\n\r\n\t\t// Send initialize message\r\n\t\tthis._onModuleLoaded = this._protocol.sendMessage(DEFAULT_CHANNEL, INITIALIZE, [\r\n\t\t\tthis._worker.getId(),\r\n\t\t\tJSON.parse(JSON.stringify(loaderConfiguration)),\r\n\t\t\tworkerDescriptor.moduleId,\r\n\t\t]);\r\n\r\n\t\tthis.proxy = this._protocol.createProxyToRemoteChannel(DEFAULT_CHANNEL, async () => { await this._onModuleLoaded; });\r\n\t\tthis._onModuleLoaded.catch((e) => {\r\n\t\t\tthis._onError('Worker failed to load ' + workerDescriptor.moduleId, e);\r\n\t\t});\r\n\t}\r\n\r\n\tprivate _handleMessage(channelName: string, method: string, args: any[]): Promise<any> {\r\n\t\tconst channel: object | undefined = this._localChannels.get(channelName);\r\n\t\tif (!channel) {\r\n\t\t\treturn Promise.reject(new Error(`Missing channel ${channelName} on main thread`));\r\n\t\t}\r\n\t\tif (typeof (channel as any)[method] !== 'function') {\r\n\t\t\treturn Promise.reject(new Error(`Missing method ${method} on main thread channel ${channelName}`));\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\treturn Promise.resolve((channel as any)[method].apply(channel, args));\r\n\t\t} catch (e) {\r\n\t\t\treturn Promise.reject(e);\r\n\t\t}\r\n\t}\r\n\r\n\tprivate _handleEvent(channelName: string, eventName: string, arg: any): Event<any> {\r\n\t\tconst channel: object | undefined = this._localChannels.get(channelName);\r\n\t\tif (!channel) {\r\n\t\t\tthrow new Error(`Missing channel ${channelName} on main thread`);\r\n\t\t}\r\n\t\tif (propertyIsDynamicEvent(eventName)) {\r\n\t\t\tconst event = (channel as any)[eventName].call(channel, arg);\r\n\t\t\tif (typeof event !== 'function') {\r\n\t\t\t\tthrow new Error(`Missing dynamic event ${eventName} on main thread channel ${channelName}.`);\r\n\t\t\t}\r\n\t\t\treturn event;\r\n\t\t}\r\n\t\tif (propertyIsEvent(eventName)) {\r\n\t\t\tconst event = (channel as any)[eventName];\r\n\t\t\tif (typeof event !== 'function') {\r\n\t\t\t\tthrow new Error(`Missing event ${eventName} on main thread channel ${channelName}.`);\r\n\t\t\t}\r\n\t\t\treturn event;\r\n\t\t}\r\n\t\tthrow new Error(`Malformed event name ${eventName}`);\r\n\t}\r\n\r\n\tpublic setChannel<T extends object>(channel: string, handler: T): void {\r\n\t\tthis._localChannels.set(channel, handler);\r\n\t}\r\n\r\n\tprivate _onError(message: string, error?: any): void {\r\n\t\tconsole.error(message);\r\n\t\tconsole.info(error);\r\n\t}\r\n}\r\n\r\nfunction propertyIsEvent(name: string): boolean {\r\n\t// Assume a property is an event if it has a form of \"onSomething\"\r\n\treturn name[0] === 'o' && name[1] === 'n' && strings.isUpperAsciiLetter(name.charCodeAt(2));\r\n}\r\n\r\nfunction propertyIsDynamicEvent(name: string): boolean {\r\n\t// Assume a property is a dynamic event (a method that returns an event) if it has a form of \"onDynamicSomething\"\r\n\treturn /^onDynamic/.test(name) && strings.isUpperAsciiLetter(name.charCodeAt(9));\r\n}\r\n\r\nexport interface IRequestHandler {\r\n\t_requestHandlerBrand: any;\r\n\t[prop: string]: any;\r\n}\r\n\r\nexport interface IRequestHandlerFactory {\r\n\t(workerServer: IWorkerServer): IRequestHandler;\r\n}\r\n\r\n/**\r\n * Worker side\r\n */\r\nexport class SimpleWorkerServer implements IWorkerServer {\r\n\r\n\tprivate _requestHandlerFactory: IRequestHandlerFactory | null;\r\n\tprivate _requestHandler: IRequestHandler | null;\r\n\tprivate _protocol: SimpleWorkerProtocol;\r\n\tprivate readonly _localChannels: Map<string, object> = new Map();\r\n\tprivate readonly _remoteChannels: Map<string, object> = new Map();\r\n\r\n\tconstructor(postMessage: (msg: Message, transfer?: ArrayBuffer[]) => void, requestHandlerFactory: IRequestHandlerFactory | null) {\r\n\t\tthis._requestHandlerFactory = requestHandlerFactory;\r\n\t\tthis._requestHandler = null;\r\n\t\tthis._protocol = new SimpleWorkerProtocol({\r\n\t\t\tsendMessage: (msg: any, transfer: ArrayBuffer[]): void => {\r\n\t\t\t\tpostMessage(msg, transfer);\r\n\t\t\t},\r\n\t\t\thandleMessage: (channel: string, method: string, args: any[]): Promise<any> => this._handleMessage(channel, method, args),\r\n\t\t\thandleEvent: (channel: string, eventName: string, arg: any): Event<any> => this._handleEvent(channel, eventName, arg)\r\n\t\t});\r\n\t}\r\n\r\n\tpublic onmessage(msg: any): void {\r\n\t\tthis._protocol.handleMessage(msg);\r\n\t}\r\n\r\n\tprivate _handleMessage(channel: string, method: string, args: any[]): Promise<any> {\r\n\t\tif (channel === DEFAULT_CHANNEL && method === INITIALIZE) {\r\n\t\t\treturn this.initialize(<number>args[0], <any>args[1], <string>args[2]);\r\n\t\t}\r\n\r\n\t\tconst requestHandler: object | null | undefined = (channel === DEFAULT_CHANNEL ? this._requestHandler : this._localChannels.get(channel));\r\n\t\tif (!requestHandler) {\r\n\t\t\treturn Promise.reject(new Error(`Missing channel ${channel} on worker thread`));\r\n\t\t}\r\n\t\tif (typeof (requestHandler as any)[method] !== 'function') {\r\n\t\t\treturn Promise.reject(new Error(`Missing method ${method} on worker thread channel ${channel}`));\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\treturn Promise.resolve((requestHandler as any)[method].apply(requestHandler, args));\r\n\t\t} catch (e) {\r\n\t\t\treturn Promise.reject(e);\r\n\t\t}\r\n\t}\r\n\r\n\tprivate _handleEvent(channel: string, eventName: string, arg: any): Event<any> {\r\n\t\tconst requestHandler: object | null | undefined = (channel === DEFAULT_CHANNEL ? this._requestHandler : this._localChannels.get(channel));\r\n\t\tif (!requestHandler) {\r\n\t\t\tthrow new Error(`Missing channel ${channel} on worker thread`);\r\n\t\t}\r\n\t\tif (propertyIsDynamicEvent(eventName)) {\r\n\t\t\tconst event = (requestHandler as any)[eventName].call(requestHandler, arg);\r\n\t\t\tif (typeof event !== 'function') {\r\n\t\t\t\tthrow new Error(`Missing dynamic event ${eventName} on request handler.`);\r\n\t\t\t}\r\n\t\t\treturn event;\r\n\t\t}\r\n\t\tif (propertyIsEvent(eventName)) {\r\n\t\t\tconst event = (requestHandler as any)[eventName];\r\n\t\t\tif (typeof event !== 'function') {\r\n\t\t\t\tthrow new Error(`Missing event ${eventName} on request handler.`);\r\n\t\t\t}\r\n\t\t\treturn event;\r\n\t\t}\r\n\t\tthrow new Error(`Malformed event name ${eventName}`);\r\n\t}\r\n\r\n\tpublic getChannel<T extends object>(channel: string): Proxied<T> {\r\n\t\tif (!this._remoteChannels.has(channel)) {\r\n\t\t\tconst inst = this._protocol.createProxyToRemoteChannel(channel);\r\n\t\t\tthis._remoteChannels.set(channel, inst);\r\n\t\t}\r\n\t\treturn this._remoteChannels.get(channel) as Proxied<T>;\r\n\t}\r\n\r\n\tprivate async initialize(workerId: number, loaderConfig: any, moduleId: string): Promise<void> {\r\n\t\tthis._protocol.setWorkerId(workerId);\r\n\r\n\t\tif (this._requestHandlerFactory) {\r\n\t\t\t// static request handler\r\n\t\t\tthis._requestHandler = this._requestHandlerFactory(this);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (loaderConfig) {\r\n\t\t\t// Remove 'baseUrl', handling it is beyond scope for now\r\n\t\t\tif (typeof loaderConfig.baseUrl !== 'undefined') {\r\n\t\t\t\tdelete loaderConfig['baseUrl'];\r\n\t\t\t}\r\n\t\t\tif (typeof loaderConfig.paths !== 'undefined') {\r\n\t\t\t\tif (typeof loaderConfig.paths.vs !== 'undefined') {\r\n\t\t\t\t\tdelete loaderConfig.paths['vs'];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (typeof loaderConfig.trustedTypesPolicy !== 'undefined') {\r\n\t\t\t\t// don't use, it has been destroyed during serialize\r\n\t\t\t\tdelete loaderConfig['trustedTypesPolicy'];\r\n\t\t\t}\r\n\r\n\t\t\t// Since this is in a web worker, enable catching errors\r\n\t\t\tloaderConfig.catchError = true;\r\n\t\t\t(globalThis as any).require.config(loaderConfig);\r\n\t\t}\r\n\r\n\t\tconst url = FileAccess.asBrowserUri(`${moduleId}.js` as AppResourcePath).toString(true);\r\n\t\treturn import(`${url}`).then((module: { create: IRequestHandlerFactory }) => {\r\n\t\t\tthis._requestHandler = module.create(this);\r\n\r\n\t\t\tif (!this._requestHandler) {\r\n\t\t\t\tthrow new Error(`No RequestHandler!`);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}\r\n\r\n/**\r\n * Defines the worker entry point. Must be exported and named `create`.\r\n * @skipMangle\r\n */\r\nexport function create(postMessage: (msg: Message, transfer?: ArrayBuffer[]) => void): SimpleWorkerServer {\r\n\treturn new SimpleWorkerServer(postMessage, null);\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nimport { CharCode } from '../charCode.js';\r\nimport { onUnexpectedError, transformErrorForSerialization } from '../errors.js';\r\nimport { Emitter, Event } from '../event.js';\r\nimport { Disposable, IDisposable } from '../lifecycle.js';\r\nimport { AppResourcePath, FileAccess } from '../network.js';\r\nimport { isWeb } from '../platform.js';\r\nimport * as strings from '../strings.js';\r\nimport { URI } from '../uri.js';\r\n\r\nconst DEFAULT_CHANNEL = 'default';\r\nconst INITIALIZE = '$initialize';\r\n\r\nexport interface IWorker extends IDisposable {\r\n\tgetId(): number;\r\n\tpostMessage(message: Message, transfer: ArrayBuffer[]): void;\r\n}\r\n\r\nexport interface IWorkerCallback {\r\n\t(message: Message): void;\r\n}\r\n\r\nexport interface IWorkerFactory {\r\n\tcreate(modules: IWorkerDescriptor, callback: IWorkerCallback, onErrorCallback: (err: any) => void): IWorker;\r\n}\r\n\r\nexport interface IWorkerDescriptor {\r\n\treadonly moduleId: string;\r\n\treadonly esmModuleLocation: URI | undefined;\r\n\treadonly label: string | undefined;\r\n}\r\n\r\nlet webWorkerWarningLogged = false;\r\nexport function logOnceWebWorkerWarning(err: any): void {\r\n\tif (!isWeb) {\r\n\t\t// running tests\r\n\t\treturn;\r\n\t}\r\n\tif (!webWorkerWarningLogged) {\r\n\t\twebWorkerWarningLogged = true;\r\n\t\tconsole.warn('Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq');\r\n\t}\r\n\tconsole.warn(err.message);\r\n}\r\n\r\nconst enum MessageType {\r\n\tRequest,\r\n\tReply,\r\n\tSubscribeEvent,\r\n\tEvent,\r\n\tUnsubscribeEvent\r\n}\r\nclass RequestMessage {\r\n\tpublic readonly type = MessageType.Request;\r\n\tconstructor(\r\n\t\tpublic readonly vsWorker: number,\r\n\t\tpublic readonly req: string,\r\n\t\tpublic readonly channel: string,\r\n\t\tpublic readonly method: string,\r\n\t\tpublic readonly args: any[]\r\n\t) { }\r\n}\r\nclass ReplyMessage {\r\n\tpublic readonly type = MessageType.Reply;\r\n\tconstructor(\r\n\t\tpublic readonly vsWorker: number,\r\n\t\tpublic readonly seq: string,\r\n\t\tpublic readonly res: any,\r\n\t\tpublic readonly err: any\r\n\t) { }\r\n}\r\nclass SubscribeEventMessage {\r\n\tpublic readonly type = MessageType.SubscribeEvent;\r\n\tconstructor(\r\n\t\tpublic readonly vsWorker: number,\r\n\t\tpublic readonly req: string,\r\n\t\tpublic readonly channel: string,\r\n\t\tpublic readonly eventName: string,\r\n\t\tpublic readonly arg: any\r\n\t) { }\r\n}\r\nclass EventMessage {\r\n\tpublic readonly type = MessageType.Event;\r\n\tconstructor(\r\n\t\tpublic readonly vsWorker: number,\r\n\t\tpublic readonly req: string,\r\n\t\tpublic readonly event: any\r\n\t) { }\r\n}\r\nclass UnsubscribeEventMessage {\r\n\tpublic readonly type = MessageType.UnsubscribeEvent;\r\n\tconstructor(\r\n\t\tpublic readonly vsWorker: number,\r\n\t\tpublic readonly req: string\r\n\t) { }\r\n}\r\ntype Message = RequestMessage | ReplyMessage | SubscribeEventMessage | EventMessage | UnsubscribeEventMessage;\r\n\r\ninterface IMessageReply {\r\n\tresolve: (value?: any) => void;\r\n\treject: (error?: any) => void;\r\n}\r\n\r\ninterface IMessageHandler {\r\n\tsendMessage(msg: any, transfer?: ArrayBuffer[]): void;\r\n\thandleMessage(channel: string, method: string, args: any[]): Promise<any>;\r\n\thandleEvent(channel: string, eventName: string, arg: any): Event<any>;\r\n}\r\n\r\nclass SimpleWorkerProtocol {\r\n\r\n\tprivate _workerId: number;\r\n\tprivate _lastSentReq: number;\r\n\tprivate _pendingReplies: { [req: string]: IMessageReply };\r\n\tprivate _pendingEmitters: Map<string, Emitter<any>>;\r\n\tprivate _pendingEvents: Map<string, IDisposable>;\r\n\tprivate _handler: IMessageHandler;\r\n\r\n\tconstructor(handler: IMessageHandler) {\r\n\t\tthis._workerId = -1;\r\n\t\tthis._handler = handler;\r\n\t\tthis._lastSentReq = 0;\r\n\t\tthis._pendingReplies = Object.create(null);\r\n\t\tthis._pendingEmitters = new Map<string, Emitter<any>>();\r\n\t\tthis._pendingEvents = new Map<string, IDisposable>();\r\n\t}\r\n\r\n\tpublic setWorkerId(workerId: number): void {\r\n\t\tthis._workerId = workerId;\r\n\t}\r\n\r\n\tpublic sendMessage(channel: string, method: string, args: any[]): Promise<any> {\r\n\t\tconst req = String(++this._lastSentReq);\r\n\t\treturn new Promise<any>((resolve, reject) => {\r\n\t\t\tthis._pendingReplies[req] = {\r\n\t\t\t\tresolve: resolve,\r\n\t\t\t\treject: reject\r\n\t\t\t};\r\n\t\t\tthis._send(new RequestMessage(this._workerId, req, channel, method, args));\r\n\t\t});\r\n\t}\r\n\r\n\tpublic listen(channel: string, eventName: string, arg: any): Event<any> {\r\n\t\tlet req: string | null = null;\r\n\t\tconst emitter = new Emitter<any>({\r\n\t\t\tonWillAddFirstListener: () => {\r\n\t\t\t\treq = String(++this._lastSentReq);\r\n\t\t\t\tthis._pendingEmitters.set(req, emitter);\r\n\t\t\t\tthis._send(new SubscribeEventMessage(this._workerId, req, channel, eventName, arg));\r\n\t\t\t},\r\n\t\t\tonDidRemoveLastListener: () => {\r\n\t\t\t\tthis._pendingEmitters.delete(req!);\r\n\t\t\t\tthis._send(new UnsubscribeEventMessage(this._workerId, req!));\r\n\t\t\t\treq = null;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn emitter.event;\r\n\t}\r\n\r\n\tpublic handleMessage(message: Message): void {\r\n\t\tif (!message || !message.vsWorker) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (this._workerId !== -1 && message.vsWorker !== this._workerId) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis._handleMessage(message);\r\n\t}\r\n\r\n\tpublic createProxyToRemoteChannel<T extends object>(channel: string, sendMessageBarrier?: () => Promise<void>): T {\r\n\t\tconst handler = {\r\n\t\t\tget: (target: any, name: PropertyKey) => {\r\n\t\t\t\tif (typeof name === 'string' && !target[name]) {\r\n\t\t\t\t\tif (propertyIsDynamicEvent(name)) { // onDynamic...\r\n\t\t\t\t\t\ttarget[name] = (arg: any): Event<any> => {\r\n\t\t\t\t\t\t\treturn this.listen(channel, name, arg);\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t} else if (propertyIsEvent(name)) { // on...\r\n\t\t\t\t\t\ttarget[name] = this.listen(channel, name, undefined);\r\n\t\t\t\t\t} else if (name.charCodeAt(0) === CharCode.DollarSign) { // $...\r\n\t\t\t\t\t\ttarget[name] = async (...myArgs: any[]) => {\r\n\t\t\t\t\t\t\tawait sendMessageBarrier?.();\r\n\t\t\t\t\t\t\treturn this.sendMessage(channel, name, myArgs);\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn target[name];\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn new Proxy(Object.create(null), handler);\r\n\t}\r\n\r\n\tprivate _handleMessage(msg: Message): void {\r\n\t\tswitch (msg.type) {\r\n\t\t\tcase MessageType.Reply:\r\n\t\t\t\treturn this._handleReplyMessage(msg);\r\n\t\t\tcase MessageType.Request:\r\n\t\t\t\treturn this._handleRequestMessage(msg);\r\n\t\t\tcase MessageType.SubscribeEvent:\r\n\t\t\t\treturn this._handleSubscribeEventMessage(msg);\r\n\t\t\tcase MessageType.Event:\r\n\t\t\t\treturn this._handleEventMessage(msg);\r\n\t\t\tcase MessageType.UnsubscribeEvent:\r\n\t\t\t\treturn this._handleUnsubscribeEventMessage(msg);\r\n\t\t}\r\n\t}\r\n\r\n\tprivate _handleReplyMessage(replyMessage: ReplyMessage): void {\r\n\t\tif (!this._pendingReplies[replyMessage.seq]) {\r\n\t\t\tconsole.warn('Got reply to unknown seq');\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst reply = this._pendingReplies[replyMessage.seq];\r\n\t\tdelete this._pendingReplies[replyMessage.seq];\r\n\r\n\t\tif (replyMessage.err) {\r\n\t\t\tlet err = replyMessage.err;\r\n\t\t\tif (replyMessage.err.$isError) {\r\n\t\t\t\terr = new Error();\r\n\t\t\t\terr.name = replyMessage.err.name;\r\n\t\t\t\terr.message = replyMessage.err.message;\r\n\t\t\t\terr.stack = replyMessage.err.stack;\r\n\t\t\t}\r\n\t\t\treply.reject(err);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\treply.resolve(replyMessage.res);\r\n\t}\r\n\r\n\tprivate _handleRequestMessage(requestMessage: RequestMessage): void {\r\n\t\tconst req = requestMessage.req;\r\n\t\tconst result = this._handler.handleMessage(requestMessage.channel, requestMessage.method, requestMessage.args);\r\n\t\tresult.then((r) => {\r\n\t\t\tthis._send(new ReplyMessage(this._workerId, req, r, undefined));\r\n\t\t}, (e) => {\r\n\t\t\tif (e.detail instanceof Error) {\r\n\t\t\t\t// Loading errors have a detail property that points to the actual error\r\n\t\t\t\te.detail = transformErrorForSerialization(e.detail);\r\n\t\t\t}\r\n\t\t\tthis._send(new ReplyMessage(this._workerId, req, undefined, transformErrorForSerialization(e)));\r\n\t\t});\r\n\t}\r\n\r\n\tprivate _handleSubscribeEventMessage(msg: SubscribeEventMessage): void {\r\n\t\tconst req = msg.req;\r\n\t\tconst disposable = this._handler.handleEvent(msg.channel, msg.eventName, msg.arg)((event) => {\r\n\t\t\tthis._send(new EventMessage(this._workerId, req, event));\r\n\t\t});\r\n\t\tthis._pendingEvents.set(req, disposable);\r\n\t}\r\n\r\n\tprivate _handleEventMessage(msg: EventMessage): void {\r\n\t\tif (!this._pendingEmitters.has(msg.req)) {\r\n\t\t\tconsole.warn('Got event for unknown req');\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis._pendingEmitters.get(msg.req)!.fire(msg.event);\r\n\t}\r\n\r\n\tprivate _handleUnsubscribeEventMessage(msg: UnsubscribeEventMessage): void {\r\n\t\tif (!this._pendingEvents.has(msg.req)) {\r\n\t\t\tconsole.warn('Got unsubscribe for unknown req');\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis._pendingEvents.get(msg.req)!.dispose();\r\n\t\tthis._pendingEvents.delete(msg.req);\r\n\t}\r\n\r\n\tprivate _send(msg: Message): void {\r\n\t\tconst transfer: ArrayBuffer[] = [];\r\n\t\tif (msg.type === MessageType.Request) {\r\n\t\t\tfor (let i = 0; i < msg.args.length; i++) {\r\n\t\t\t\tif (msg.args[i] instanceof ArrayBuffer) {\r\n\t\t\t\t\ttransfer.push(msg.args[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (msg.type === MessageType.Reply) {\r\n\t\t\tif (msg.res instanceof ArrayBuffer) {\r\n\t\t\t\ttransfer.push(msg.res);\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis._handler.sendMessage(msg, transfer);\r\n\t}\r\n}\r\n\r\ntype ProxiedMethodName = (`$${string}` | `on${string}`);\r\n\r\nexport type Proxied<T> = { [K in keyof T]: T[K] extends (...args: infer A) => infer R\r\n\t? (\r\n\t\tK extends ProxiedMethodName\r\n\t\t? (...args: A) => Promise<Awaited<R>>\r\n\t\t: never\r\n\t)\r\n\t: never\r\n};\r\n\r\nexport interface IWorkerClient<W> {\r\n\tproxy: Proxied<W>;\r\n\tdispose(): void;\r\n\tsetChannel<T extends object>(channel: string, handler: T): void;\r\n}\r\n\r\nexport interface IWorkerServer {\r\n\tgetChannel<T extends object>(channel: string): Proxied<T>;\r\n}\r\n\r\n/**\r\n * Main thread side\r\n */\r\nexport class SimpleWorkerClient<W extends object> extends Disposable implements IWorkerClient<W> {\r\n\r\n\tprivate readonly _worker: IWorker;\r\n\tprivate readonly _onModuleLoaded: Promise<void>;\r\n\tprivate readonly _protocol: SimpleWorkerProtocol;\r\n\tpublic readonly proxy: Proxied<W>;\r\n\tprivate readonly _localChannels: Map<string, object> = new Map();\r\n\r\n\tconstructor(\r\n\t\tworkerFactory: IWorkerFactory,\r\n\t\tworkerDescriptor: IWorkerDescriptor,\r\n\t) {\r\n\t\tsuper();\r\n\r\n\t\tthis._worker = this._register(workerFactory.create(\r\n\t\t\t{\r\n\t\t\t\tmoduleId: 'vs/base/common/worker/simpleWorker',\r\n\t\t\t\tesmModuleLocation: workerDescriptor.esmModuleLocation,\r\n\t\t\t\tlabel: workerDescriptor.label\r\n\t\t\t},\r\n\t\t\t(msg: Message) => {\r\n\t\t\t\tthis._protocol.handleMessage(msg);\r\n\t\t\t},\r\n\t\t\t(err: any) => {\r\n\t\t\t\t// in Firefox, web workers fail lazily :(\r\n\t\t\t\t// we will reject the proxy\r\n\t\t\t\tonUnexpectedError(err);\r\n\t\t\t}\r\n\t\t));\r\n\r\n\t\tthis._protocol = new SimpleWorkerProtocol({\r\n\t\t\tsendMessage: (msg: any, transfer: ArrayBuffer[]): void => {\r\n\t\t\t\tthis._worker.postMessage(msg, transfer);\r\n\t\t\t},\r\n\t\t\thandleMessage: (channel: string, method: string, args: any[]): Promise<any> => {\r\n\t\t\t\treturn this._handleMessage(channel, method, args);\r\n\t\t\t},\r\n\t\t\thandleEvent: (channel: string, eventName: string, arg: any): Event<any> => {\r\n\t\t\t\treturn this._handleEvent(channel, eventName, arg);\r\n\t\t\t}\r\n\t\t});\r\n\t\tthis._protocol.setWorkerId(this._worker.getId());\r\n\r\n\t\t// Gather loader configuration\r\n\t\tlet loaderConfiguration: any = null;\r\n\r\n\t\tconst globalRequire: { getConfig?(): object } | undefined = (globalThis as any).require;\r\n\t\tif (typeof globalRequire !== 'undefined' && typeof globalRequire.getConfig === 'function') {\r\n\t\t\t// Get the configuration from the Monaco AMD Loader\r\n\t\t\tloaderConfiguration = globalRequire.getConfig();\r\n\t\t} else if (typeof (globalThis as any).requirejs !== 'undefined') {\r\n\t\t\t// Get the configuration from requirejs\r\n\t\t\tloaderConfiguration = (globalThis as any).requirejs.s.contexts._.config;\r\n\t\t}\r\n\r\n\t\t// Send initialize message\r\n\t\tthis._onModuleLoaded = this._protocol.sendMessage(DEFAULT_CHANNEL, INITIALIZE, [\r\n\t\t\tthis._worker.getId(),\r\n\t\t\tJSON.parse(JSON.stringify(loaderConfiguration)),\r\n\t\t\tworkerDescriptor.moduleId,\r\n\t\t]);\r\n\r\n\t\tthis.proxy = this._protocol.createProxyToRemoteChannel(DEFAULT_CHANNEL, async () => { await this._onModuleLoaded; });\r\n\t\tthis._onModuleLoaded.catch((e) => {\r\n\t\t\tthis._onError('Worker failed to load ' + workerDescriptor.moduleId, e);\r\n\t\t});\r\n\t}\r\n\r\n\tprivate _handleMessage(channelName: string, method: string, args: any[]): Promise<any> {\r\n\t\tconst channel: object | undefined = this._localChannels.get(channelName);\r\n\t\tif (!channel) {\r\n\t\t\treturn Promise.reject(new Error(`Missing channel ${channelName} on main thread`));\r\n\t\t}\r\n\t\tif (typeof (channel as any)[method] !== 'function') {\r\n\t\t\treturn Promise.reject(new Error(`Missing method ${method} on main thread channel ${channelName}`));\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\treturn Promise.resolve((channel as any)[method].apply(channel, args));\r\n\t\t} catch (e) {\r\n\t\t\treturn Promise.reject(e);\r\n\t\t}\r\n\t}\r\n\r\n\tprivate _handleEvent(channelName: string, eventName: string, arg: any): Event<any> {\r\n\t\tconst channel: object | undefined = this._localChannels.get(channelName);\r\n\t\tif (!channel) {\r\n\t\t\tthrow new Error(`Missing channel ${channelName} on main thread`);\r\n\t\t}\r\n\t\tif (propertyIsDynamicEvent(eventName)) {\r\n\t\t\tconst event = (channel as any)[eventName].call(channel, arg);\r\n\t\t\tif (typeof event !== 'function') {\r\n\t\t\t\tthrow new Error(`Missing dynamic event ${eventName} on main thread channel ${channelName}.`);\r\n\t\t\t}\r\n\t\t\treturn event;\r\n\t\t}\r\n\t\tif (propertyIsEvent(eventName)) {\r\n\t\t\tconst event = (channel as any)[eventName];\r\n\t\t\tif (typeof event !== 'function') {\r\n\t\t\t\tthrow new Error(`Missing event ${eventName} on main thread channel ${channelName}.`);\r\n\t\t\t}\r\n\t\t\treturn event;\r\n\t\t}\r\n\t\tthrow new Error(`Malformed event name ${eventName}`);\r\n\t}\r\n\r\n\tpublic setChannel<T extends object>(channel: string, handler: T): void {\r\n\t\tthis._localChannels.set(channel, handler);\r\n\t}\r\n\r\n\tprivate _onError(message: string, error?: any): void {\r\n\t\tconsole.error(message);\r\n\t\tconsole.info(error);\r\n\t}\r\n}\r\n\r\nfunction propertyIsEvent(name: string): boolean {\r\n\t// Assume a property is an event if it has a form of \"onSomething\"\r\n\treturn name[0] === 'o' && name[1] === 'n' && strings.isUpperAsciiLetter(name.charCodeAt(2));\r\n}\r\n\r\nfunction propertyIsDynamicEvent(name: string): boolean {\r\n\t// Assume a property is a dynamic event (a method that returns an event) if it has a form of \"onDynamicSomething\"\r\n\treturn /^onDynamic/.test(name) && strings.isUpperAsciiLetter(name.charCodeAt(9));\r\n}\r\n\r\nexport interface IRequestHandler {\r\n\t_requestHandlerBrand: any;\r\n\t[prop: string]: any;\r\n}\r\n\r\nexport interface IRequestHandlerFactory {\r\n\t(workerServer: IWorkerServer): IRequestHandler;\r\n}\r\n\r\n/**\r\n * Worker side\r\n */\r\nexport class SimpleWorkerServer implements IWorkerServer {\r\n\r\n\tprivate _requestHandlerFactory: IRequestHandlerFactory | null;\r\n\tprivate _requestHandler: IRequestHandler | null;\r\n\tprivate _protocol: SimpleWorkerProtocol;\r\n\tprivate readonly _localChannels: Map<string, object> = new Map();\r\n\tprivate readonly _remoteChannels: Map<string, object> = new Map();\r\n\r\n\tconstructor(postMessage: (msg: Message, transfer?: ArrayBuffer[]) => void, requestHandlerFactory: IRequestHandlerFactory | null) {\r\n\t\tthis._requestHandlerFactory = requestHandlerFactory;\r\n\t\tthis._requestHandler = null;\r\n\t\tthis._protocol = new SimpleWorkerProtocol({\r\n\t\t\tsendMessage: (msg: any, transfer: ArrayBuffer[]): void => {\r\n\t\t\t\tpostMessage(msg, transfer);\r\n\t\t\t},\r\n\t\t\thandleMessage: (channel: string, method: string, args: any[]): Promise<any> => this._handleMessage(channel, method, args),\r\n\t\t\thandleEvent: (channel: string, eventName: string, arg: any): Event<any> => this._handleEvent(channel, eventName, arg)\r\n\t\t});\r\n\t}\r\n\r\n\tpublic onmessage(msg: any): void {\r\n\t\tthis._protocol.handleMessage(msg);\r\n\t}\r\n\r\n\tprivate _handleMessage(channel: string, method: string, args: any[]): Promise<any> {\r\n\t\tif (channel === DEFAULT_CHANNEL && method === INITIALIZE) {\r\n\t\t\treturn this.initialize(<number>args[0], <any>args[1], <string>args[2]);\r\n\t\t}\r\n\r\n\t\tconst requestHandler: object | null | undefined = (channel === DEFAULT_CHANNEL ? this._requestHandler : this._localChannels.get(channel));\r\n\t\tif (!requestHandler) {\r\n\t\t\treturn Promise.reject(new Error(`Missing channel ${channel} on worker thread`));\r\n\t\t}\r\n\t\tif (typeof (requestHandler as any)[method] !== 'function') {\r\n\t\t\treturn Promise.reject(new Error(`Missing method ${method} on worker thread channel ${channel}`));\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\treturn Promise.resolve((requestHandler as any)[method].apply(requestHandler, args));\r\n\t\t} catch (e) {\r\n\t\t\treturn Promise.reject(e);\r\n\t\t}\r\n\t}\r\n\r\n\tprivate _handleEvent(channel: string, eventName: string, arg: any): Event<any> {\r\n\t\tconst requestHandler: object | null | undefined = (channel === DEFAULT_CHANNEL ? this._requestHandler : this._localChannels.get(channel));\r\n\t\tif (!requestHandler) {\r\n\t\t\tthrow new Error(`Missing channel ${channel} on worker thread`);\r\n\t\t}\r\n\t\tif (propertyIsDynamicEvent(eventName)) {\r\n\t\t\tconst event = (requestHandler as any)[eventName].call(requestHandler, arg);\r\n\t\t\tif (typeof event !== 'function') {\r\n\t\t\t\tthrow new Error(`Missing dynamic event ${eventName} on request handler.`);\r\n\t\t\t}\r\n\t\t\treturn event;\r\n\t\t}\r\n\t\tif (propertyIsEvent(eventName)) {\r\n\t\t\tconst event = (requestHandler as any)[eventName];\r\n\t\t\tif (typeof event !== 'function') {\r\n\t\t\t\tthrow new Error(`Missing event ${eventName} on request handler.`);\r\n\t\t\t}\r\n\t\t\treturn event;\r\n\t\t}\r\n\t\tthrow new Error(`Malformed event name ${eventName}`);\r\n\t}\r\n\r\n\tpublic getChannel<T extends object>(channel: string): Proxied<T> {\r\n\t\tif (!this._remoteChannels.has(channel)) {\r\n\t\t\tconst inst = this._protocol.createProxyToRemoteChannel(channel);\r\n\t\t\tthis._remoteChannels.set(channel, inst);\r\n\t\t}\r\n\t\treturn this._remoteChannels.get(channel) as Proxied<T>;\r\n\t}\r\n\r\n\tprivate async initialize(workerId: number, loaderConfig: any, moduleId: string): Promise<void> {\r\n\t\tthis._protocol.setWorkerId(workerId);\r\n\r\n\t\tif (this._requestHandlerFactory) {\r\n\t\t\t// static request handler\r\n\t\t\tthis._requestHandler = this._requestHandlerFactory(this);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (loaderConfig) {\r\n\t\t\t// Remove 'baseUrl', handling it is beyond scope for now\r\n\t\t\tif (typeof loaderConfig.baseUrl !== 'undefined') {\r\n\t\t\t\tdelete loaderConfig['baseUrl'];\r\n\t\t\t}\r\n\t\t\tif (typeof loaderConfig.paths !== 'undefined') {\r\n\t\t\t\tif (typeof loaderConfig.paths.vs !== 'undefined') {\r\n\t\t\t\t\tdelete loaderConfig.paths['vs'];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (typeof loaderConfig.trustedTypesPolicy !== 'undefined') {\r\n\t\t\t\t// don't use, it has been destroyed during serialize\r\n\t\t\t\tdelete loaderConfig['trustedTypesPolicy'];\r\n\t\t\t}\r\n\r\n\t\t\t// Since this is in a web worker, enable catching errors\r\n\t\t\tloaderConfig.catchError = true;\r\n\t\t\t(globalThis as any).require.config(loaderConfig);\r\n\t\t}\r\n\r\n\t\tconst url = FileAccess.asBrowserUri(`${moduleId}.js` as AppResourcePath).toString(true);\r\n\t\treturn import(`${url}`).then((module: { create: IRequestHandlerFactory }) => {\r\n\t\t\tthis._requestHandler = module.create(this);\r\n\r\n\t\t\tif (!this._requestHandler) {\r\n\t\t\t\tthrow new Error(`No RequestHandler!`);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}\r\n\r\n/**\r\n * Defines the worker entry point. Must be exported and named `create`.\r\n * @skipMangle\r\n */\r\nexport function create(postMessage: (msg: Message, transfer?: ArrayBuffer[]) => void): SimpleWorkerServer {\r\n\treturn new SimpleWorkerServer(postMessage, null);\r\n}\r\n"],"mappings":"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","names":["exports","logOnceWebWorkerWarning","create","DEFAULT_CHANNEL","INITIALIZE","webWorkerWarningLogged","err","platform_js_1","RequestMessage","vsWorker","req","channel","method","args","ReplyMessage","seq","res","SubscribeEventMessage","eventName","arg","EventMessage","event","UnsubscribeEventMessage","SimpleWorkerProtocol","handler","workerId","resolve","reject","emitter","event_js_1","message","sendMessageBarrier","target","name","propertyIsDynamicEvent","propertyIsEvent","myArgs","msg","replyMessage","reply","requestMessage","r","e","errors_js_1","disposable","transfer","i","SimpleWorkerClient","lifecycle_js_1","workerFactory","workerDescriptor","loaderConfiguration","globalRequire","channelName","error","strings","SimpleWorkerServer","postMessage","requestHandlerFactory","requestHandler","inst","loaderConfig","moduleId","url","network_js_1","resolve_1","reject_1","require","module"],"file":"workerMain.js"}